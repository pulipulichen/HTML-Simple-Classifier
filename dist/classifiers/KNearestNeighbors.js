(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{225:function(module,exports){eval('module.exports = function (Component) {\n  Component.options.__i18n = Component.options.__i18n || []\n  Component.options.__i18n.push(\'{"en":{"TEST_MESSAGE":"Test Message"},"zh-TW":{"TEST_MESSAGE":"測試訊息"}}\')\n  delete Component.options._Ctor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLnlhbWw/ZTc2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuID0gQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuIHx8IFtdXG4gIENvbXBvbmVudC5vcHRpb25zLl9faTE4bi5wdXNoKCd7XCJlblwiOntcIlRFU1RfTUVTU0FHRVwiOlwiVGVzdCBNZXNzYWdlXCJ9LFwiemgtVFdcIjp7XCJURVNUX01FU1NBR0VcIjpcIua4rOippuioiuaBr1wifX0nKVxuICBkZWxldGUgQ29tcG9uZW50Lm9wdGlvbnMuX0N0b3Jcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///225\n')},415:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredEuclidean", function() { return squaredEuclidean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "euclidean", function() { return euclidean; });\nfunction squaredEuclidean(p, q) {\r\n    let d = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        d += (p[i] - q[i]) * (p[i] - q[i]);\r\n    }\r\n    return d;\r\n}\r\nfunction euclidean(p, q) {\r\n    return Math.sqrt(squaredEuclidean(p, q));\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLWRpc3RhbmNlLWV1Y2xpZGVhbi9saWItZXM2L2V1Y2xpZGVhbi5qcz81OWU3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRXVjbGlkZWFuKHAsIHEpIHtcclxuICAgIGxldCBkID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGQgKz0gKHBbaV0gLSBxW2ldKSAqIChwW2ldIC0gcVtpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXVjbGlkZWFuKHAsIHEpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlZEV1Y2xpZGVhbihwLCBxKSk7XHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///415\n')},416:function(module,exports,__webpack_require__){eval("var api = __webpack_require__(6);\n            var content = __webpack_require__(546);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/MTNjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMyEuL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01Y2RmOWY4MCZwcm9kJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///416\n")},545:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_5cdf9f80_prod_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(416);\n/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_5cdf9f80_prod_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_5cdf9f80_prod_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/MDljOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMyEuL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01Y2RmOWY4MCZwcm9kJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///545\n")},546:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(5);\nexports = ___CSS_LOADER_API_IMPORT___(true);\n// Module\nexports.push([module.i, "", "",{"version":3,"sources":[],"names":[],"mappings":"","file":"KNearestNeighbors.less"}]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/OTcwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJmaWxlXCI6XCJLTmVhcmVzdE5laWdoYm9ycy5sZXNzXCJ9XSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///546\n')},547:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(225);\n/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__);\n /* harmony default export */ __webpack_exports__["default"] = (_node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLnlhbWw/NjA4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2F6dXBvbi92dWUtaTE4bi1sb2FkZXIvbGliL2luZGV4LmpzIS4vS05lYXJlc3ROZWlnaGJvcnMueWFtbD92dWUmdHlwZT1jdXN0b20maW5kZXg9MCZibG9ja1R5cGU9aTE4biZpc3N1ZXJQYXRoPSUyRmFwcCUyRnNyYyUyRmNvbXBvbmVudHMlMkZDb25maWd1cmF0aW9uUGFuZWwlMkZLTmVhcmVzdE5laWdoYm9ycyUyRktOZWFyZXN0TmVpZ2hib3JzLnZ1ZSZsYW5nPXlhbWxcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGthenVwb24vdnVlLWkxOG4tbG9hZGVyL2xpYi9pbmRleC5qcyEuL0tOZWFyZXN0TmVpZ2hib3JzLnlhbWw/dnVlJnR5cGU9Y3VzdG9tJmluZGV4PTAmYmxvY2tUeXBlPWkxOG4maXNzdWVyUGF0aD0lMkZhcHAlMkZzcmMlMkZjb21wb25lbnRzJTJGQ29uZmlndXJhdGlvblBhbmVsJTJGS05lYXJlc3ROZWlnaGJvcnMlMkZLTmVhcmVzdE5laWdoYm9ycy52dWUmbGFuZz15YW1sXCIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///547\n')},575:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--6!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.html?vue&type=template&id=5cdf9f80&scoped=true&\nvar render = function render() {\n  var _vm = this,\n    _c = _vm._self._c;\n  return _c("div", {\n    staticClass: "DecisionTree"\n  }, [_c("div", {\n    staticClass: "field"\n  }, [_c("label", {\n    attrs: {\n      "for": "KNearestNeighborsOptionsK"\n    }\n  }, [_vm._v(_vm._s(_vm.$t("K-nearest neighbor")))]), _vm._v(" "), _c("input", {\n    directives: [{\n      name: "model",\n      rawName: "v-model",\n      value: _vm.localConfig.KNearestNeighborsOptionsK,\n      expression: "localConfig.KNearestNeighborsOptionsK"\n    }],\n    attrs: {\n      type: "number",\n      min: "2",\n      id: "KNearestNeighborsOptionsK"\n    },\n    domProps: {\n      value: _vm.localConfig.KNearestNeighborsOptionsK\n    },\n    on: {\n      input: function input($event) {\n        if ($event.target.composing) return;\n        _vm.$set(_vm.localConfig, "KNearestNeighborsOptionsK", $event.target.value);\n      }\n    }\n  })]), _vm._v(" "), !_vm.isModelBuilded ? _c("div", {\n    staticClass: "ui field"\n  }, [_c("button", {\n    staticClass: "ui primary fluid button",\n    attrs: {\n      type: "button"\n    },\n    on: {\n      click: _vm.start\n    }\n  }, [[_vm._v("\\r\\n        " + _vm._s(_vm.$t("Build Model and Predict")) + "\\r\\n      ")]], 2)]) : _vm._e(), _vm._v(" "), _vm.isModelBuilded && !_vm.isModelUnsupervised ? _c("div", {\n    staticClass: "ui field"\n  }, [_c("button", {\n    staticClass: "ui primary fluid button",\n    "class": {\n      disabled: !_vm.$parent.isNeedPredict\n    },\n    attrs: {\n      type: "button"\n    },\n    on: {\n      click: _vm.start\n    }\n  }, [[_vm._v("\\r\\n        " + _vm._s(_vm.$t("Predict")) + "\\r\\n      ")]], 2)]) : _vm._e(), _vm._v(" "), _vm.isModelBuilded ? _c("div", {\n    staticClass: "ui field"\n  }, [_c("button", {\n    staticClass: "ui primary fluid button",\n    attrs: {\n      type: "button"\n    },\n    on: {\n      click: _vm.showModel\n    }\n  }, [_vm._v("\\r\\n      " + _vm._s(_vm.$t("Show Model")) + "\\r\\n    ")])]) : _vm._e()]);\n};\nvar staticRenderFns = [];\nrender._withStripped = true;\n\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.html?vue&type=template&id=5cdf9f80&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(1);\nvar asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__(0);\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n\n// EXTERNAL MODULE: ./node_modules/ml-distance-euclidean/lib-es6/euclidean.js\nvar euclidean = __webpack_require__(415);\n\n// CONCATENATED MODULE: ./node_modules/ml-knn/src/KDTree.js\n/*\n * Original code from:\n *\n * k-d Tree JavaScript - V 1.01\n *\n * https://github.com/ubilabs/kd-tree-javascript\n *\n * @author Mircea Pricop <pricop@ubilabs.net>, 2012\n * @author Martin Kleppe <kleppe@ubilabs.net>, 2012\n * @author Ubilabs http://ubilabs.net, 2012\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */\n\nfunction Node(obj, dimension, parent) {\n  this.obj = obj;\n  this.left = null;\n  this.right = null;\n  this.parent = parent;\n  this.dimension = dimension;\n}\n\nclass KDTree {\n  constructor(points, metric) {\n    // If points is not an array, assume we\'re loading a pre-built tree\n    if (!Array.isArray(points)) {\n      this.dimensions = points.dimensions;\n      this.root = points;\n      restoreParent(this.root);\n    } else {\n      this.dimensions = new Array(points[0].length);\n      for (var i = 0; i < this.dimensions.length; i++) {\n        this.dimensions[i] = i;\n      }\n      this.root = buildTree(points, 0, null, this.dimensions);\n    }\n    this.metric = metric;\n  }\n\n  // Convert to a JSON serializable structure; this just requires removing\n  // the `parent` property\n  toJSON() {\n    const result = toJSONImpl(this.root, true);\n    result.dimensions = this.dimensions;\n    return result;\n  }\n\n  nearest(point, maxNodes, maxDistance) {\n    const metric = this.metric;\n    const dimensions = this.dimensions;\n    var i;\n\n    const bestNodes = new BinaryHeap(function (e) {\n      return -e[1];\n    });\n\n    function nearestSearch(node) {\n      const dimension = dimensions[node.dimension];\n      const ownDistance = metric(point, node.obj);\n      const linearPoint = {};\n      var bestChild, linearDistance, otherChild, i;\n\n      function saveNode(node, distance) {\n        bestNodes.push([node, distance]);\n        if (bestNodes.size() > maxNodes) {\n          bestNodes.pop();\n        }\n      }\n\n      for (i = 0; i < dimensions.length; i += 1) {\n        if (i === node.dimension) {\n          linearPoint[dimensions[i]] = point[dimensions[i]];\n        } else {\n          linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n        }\n      }\n\n      linearDistance = metric(linearPoint, node.obj);\n\n      if (node.right === null && node.left === null) {\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n          saveNode(node, ownDistance);\n        }\n        return;\n      }\n\n      if (node.right === null) {\n        bestChild = node.left;\n      } else if (node.left === null) {\n        bestChild = node.right;\n      } else {\n        if (point[dimension] < node.obj[dimension]) {\n          bestChild = node.left;\n        } else {\n          bestChild = node.right;\n        }\n      }\n\n      nearestSearch(bestChild);\n\n      if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n        saveNode(node, ownDistance);\n      }\n\n      if (\n        bestNodes.size() < maxNodes ||\n        Math.abs(linearDistance) < bestNodes.peek()[1]\n      ) {\n        if (bestChild === node.left) {\n          otherChild = node.right;\n        } else {\n          otherChild = node.left;\n        }\n        if (otherChild !== null) {\n          nearestSearch(otherChild);\n        }\n      }\n    }\n\n    if (maxDistance) {\n      for (i = 0; i < maxNodes; i += 1) {\n        bestNodes.push([null, maxDistance]);\n      }\n    }\n\n    if (this.root) {\n      nearestSearch(this.root);\n    }\n\n    const result = [];\n    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\n      if (bestNodes.content[i][0]) {\n        result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\n      }\n    }\n    return result;\n  }\n}\n\nfunction toJSONImpl(src) {\n  const dest = new Node(src.obj, src.dimension, null);\n  if (src.left) dest.left = toJSONImpl(src.left);\n  if (src.right) dest.right = toJSONImpl(src.right);\n  return dest;\n}\n\nfunction buildTree(points, depth, parent, dimensions) {\n  const dim = depth % dimensions.length;\n\n  if (points.length === 0) {\n    return null;\n  }\n  if (points.length === 1) {\n    return new Node(points[0], dim, parent);\n  }\n\n  points.sort((a, b) => a[dimensions[dim]] - b[dimensions[dim]]);\n\n  const median = Math.floor(points.length / 2);\n  const node = new Node(points[median], dim, parent);\n  node.left = buildTree(points.slice(0, median), depth + 1, node, dimensions);\n  node.right = buildTree(points.slice(median + 1), depth + 1, node, dimensions);\n\n  return node;\n}\n\nfunction restoreParent(root) {\n  if (root.left) {\n    root.left.parent = root;\n    restoreParent(root.left);\n  }\n\n  if (root.right) {\n    root.right.parent = root;\n    restoreParent(root.right);\n  }\n}\n\n// Binary heap implementation from:\n// http://eloquentjavascript.net/appendix2.html\nclass BinaryHeap {\n  constructor(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  }\n\n  peek() {\n    return this.content[0];\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n];\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element\'s index, and fetch it.\n      const parentN = Math.floor((n + 1) / 2) - 1;\n      const parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update \'n\' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to move it further.\n        break;\n      }\n    }\n  }\n\n  sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        var child1Score = this.scoreFunction(child1);\n        // If the score is less than our element\'s, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } else {\n        // Otherwise, we are done.\n        break;\n      }\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/ml-knn/src/index.js\n\n\n\n\nclass src_KNN {\n  /**\n   * @param {Array} dataset\n   * @param {Array} labels\n   * @param {object} options\n   * @param {number} [options.k=numberOfClasses + 1] - Number of neighbors to classify.\n   * @param {function} [options.distance=euclideanDistance] - Distance function that takes two parameters.\n   */\n  constructor(dataset, labels, options = {}) {\n    if (dataset === true) {\n      const model = labels;\n      this.kdTree = new KDTree(model.kdTree, options);\n      this.k = model.k;\n      this.classes = new Set(model.classes);\n      this.isEuclidean = model.isEuclidean;\n      return;\n    }\n\n    const classes = new Set(labels);\n\n    const { distance = euclidean["euclidean"], k = classes.size + 1 } = options;\n\n    const points = new Array(dataset.length);\n    for (var i = 0; i < points.length; ++i) {\n      points[i] = dataset[i].slice();\n    }\n\n    for (i = 0; i < labels.length; ++i) {\n      points[i].push(labels[i]);\n    }\n\n    this.kdTree = new KDTree(points, distance);\n    this.k = k;\n    this.classes = classes;\n    this.isEuclidean = distance === euclidean["euclidean"];\n  }\n\n  /**\n   * Create a new KNN instance with the given model.\n   * @param {object} model\n   * @param {function} distance=euclideanDistance - distance function must be provided if the model wasn\'t trained with euclidean distance.\n   * @return {KNN}\n   */\n  static load(model, distance = euclidean["euclidean"]) {\n    if (model.name !== \'KNN\') {\n      throw new Error(`invalid model: ${model.name}`);\n    }\n    if (!model.isEuclidean && distance === euclidean["euclidean"]) {\n      throw new Error(\n        \'a custom distance function was used to create the model. Please provide it again\'\n      );\n    }\n    if (model.isEuclidean && distance !== euclidean["euclidean"]) {\n      throw new Error(\n        \'the model was created with the default distance function. Do not load it with another one\'\n      );\n    }\n    return new src_KNN(true, model, distance);\n  }\n\n  /**\n   * Return a JSON containing the kd-tree model.\n   * @return {object} JSON KNN model.\n   */\n  toJSON() {\n    return {\n      name: \'KNN\',\n      kdTree: this.kdTree,\n      k: this.k,\n      classes: Array.from(this.classes),\n      isEuclidean: this.isEuclidean\n    };\n  }\n\n  /**\n   * Predicts the output given the matrix to predict.\n   * @param {Array} dataset\n   * @return {Array} predictions\n   */\n  predict(dataset) {\n    if (Array.isArray(dataset)) {\n      if (typeof dataset[0] === \'number\') {\n        return getSinglePrediction(this, dataset);\n      } else if (\n        Array.isArray(dataset[0]) &&\n        typeof dataset[0][0] === \'number\'\n      ) {\n        const predictions = new Array(dataset.length);\n        for (var i = 0; i < dataset.length; i++) {\n          predictions[i] = getSinglePrediction(this, dataset[i]);\n        }\n        return predictions;\n      }\n    }\n    throw new TypeError(\'dataset to predict must be an array or a matrix\');\n  }\n}\n\nfunction getSinglePrediction(knn, currentCase) {\n  var nearestPoints = knn.kdTree.nearest(currentCase, knn.k);\n  var pointsPerClass = {};\n  var predictedClass = -1;\n  var maxPoints = -1;\n  var lastElement = nearestPoints[0][0].length - 1;\n\n  for (var element of knn.classes) {\n    pointsPerClass[element] = 0;\n  }\n\n  for (var i = 0; i < nearestPoints.length; ++i) {\n    var currentClass = nearestPoints[i][0][lastElement];\n    var currentPoints = ++pointsPerClass[currentClass];\n    if (currentPoints > maxPoints) {\n      predictedClass = currentClass;\n      maxPoints = currentPoints;\n    }\n  }\n\n  return predictedClass;\n}\n\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighborsMethodsBuild.js\n\n\n\n/* harmony default export */ var KNearestNeighborsMethodsBuild = (function (KNearestNeighbors) {\n  KNearestNeighbors.methods.startPredict = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return this.start();\n          case 2:\n            return _context.abrupt("return", _context.sent);\n          case 3:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  KNearestNeighbors.methods.start = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n    var _this = this;\n    var data, predictVector, predictResults, testSetRowIndexes, predictVectorToEvalute;\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            //this.localConfig.modelJSON = null\n            this.config.loadingProgress = 0;\n            // console.log(\'start\', 1)\n\n            this.localConfig.modelJSON = null;\n            this.localConfig.modelEvaluations = [];\n            _context2.next = 5;\n            return this.$parent.getVectorData();\n          case 5:\n            data = _context2.sent;\n            this.dataToShow = data;\n            if (data.trainSetClasses.length === 0) {\n              console.error(\'No trainSetClasses\');\n              //throw Error(\'No trainSetClasses\')\n            }\n\n            // console.log(data)\n            //return false\n            this.config.loadingProgress = 0.25;\n\n            // console.log(\'start\', 2)\n            //console.log(data.trainSet[0])\n\n            // console.log(\'start\', 3)\n            if (!(data.trainSetClasses.length > 0)) {\n              _context2.next = 28;\n              break;\n            }\n            if (!this.localConfig.modelJSON) {\n              this.model = this.buildModel(data);\n              this.localConfig.modelJSON = this.model;\n            } else {\n              this.model = src_KNN.load(this.localConfig.modelJSON);\n            }\n\n            //console.log(this.model.toJSON())\n\n            //console.log(this.model)\n            // console.log(\'start\', 5)\n\n            this.config.loadingProgress = 0.5;\n\n            // console.log(\'start\', 9)\n            //console.log(data.testSet)\n            _context2.next = 14;\n            return this.getPredictResultsVector(this.model, data);\n          case 14:\n            predictVector = _context2.sent;\n            _context2.next = 17;\n            return this.getPredictResultsValue(data, predictVector);\n          case 17:\n            predictResults = _context2.sent;\n            if (!(predictResults[0] === \'undefined\')) {\n              _context2.next = 22;\n              break;\n            }\n            this.config.loadingProgress = 1;\n            console.error(\'predict is undefined\');\n            return _context2.abrupt("return", false);\n          case 22:\n            // console.log(\'start\', 10)\n            this.config.loadingProgress = 0.75;\n            if (this.$parent.hasModelEvaluated === false) {\n              testSetRowIndexes = data.testSetRowIndexes;\n              this.unknownsPrediction = [];\n              predictVectorToEvalute = predictVector.filter(function (value, i) {\n                var notMatch = testSetRowIndexes.indexOf(i) === -1;\n                if (notMatch === false) {\n                  _this.unknownsPrediction.push(value);\n                }\n                return notMatch;\n              });\n              this.evaluationResults(data.trainSetClasses, predictVectorToEvalute);\n            }\n\n            //console.log(predictResults)\n            this.$parent.setPredictResults(predictResults);\n            this.config.loadingProgress = 0.9;\n            _context2.next = 29;\n            break;\n          case 28:\n            this.model = \'unsupervised\';\n          case 29:\n            if (this.$parent.isModelWindowOpened) {\n              this.showModel();\n            }\n            this.config.loadingProgress = 1;\n            this.config.modelBuildedTime = new Date().getTime();\n          case 32:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n  KNearestNeighbors.methods.buildModel = function (data) {\n    var testSetRowIndexes = data.testSetRowIndexes;\n    var dataset = data.testSet.filter(function (row, i) {\n      return testSetRowIndexes.indexOf(i) === -1;\n    });\n\n    // console.log(dataset)\n    var predictions = data.trainSetClasses;\n    if (dataset.length === 0) {\n      dataset = data.testSet;\n      predictions = dataset.map(function (item) {\n        return \'unknown\';\n      });\n    }\n    if (dataset.length !== predictions.length) {\n      console.error(\'length is not match\');\n    }\n    return new src_KNN(dataset, predictions, {\n      k: this.localConfig.KNearestNeighborsOptionsK\n    });\n  };\n  KNearestNeighbors.methods.getPredictResultsVector = /*#__PURE__*/function () {\n    var _ref3 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3(model, data) {\n      var testSet, resultVector;\n      return regenerator_default.a.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              testSet = data.testSet;\n              resultVector = model.predict(testSet);\n              return _context3.abrupt("return", resultVector);\n            case 3:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return function (_x, _x2) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  KNearestNeighbors.methods.getPredictResultsValue = /*#__PURE__*/function () {\n    var _ref4 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee4(data, resultVector) {\n      var trainSetClassesDict;\n      return regenerator_default.a.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              trainSetClassesDict = data.trainSetClassesDict; //console.log(trainSetClassesDict)\n              return _context4.abrupt("return", resultVector.map(function (index) {\n                return trainSetClassesDict[index];\n              }));\n            case 2:\n            case "end":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return function (_x3, _x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  KNearestNeighbors.methods.evaluationResults = /*#__PURE__*/function () {\n    var _ref5 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee5(train, predict) {\n      var accuracy, accuracyInfo;\n      return regenerator_default.a.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              this.$parent.resetModelEvaluation();\n              // console.log(train)\n              // console.log(predict)\n              //console.log(data.trainSetClasses.length, getTrainSetPredicts.length, data.testSetRowIndexes.length)\n              _context5.next = 3;\n              return this.$parent.calcAccuracy(train, predict);\n            case 3:\n              accuracy = _context5.sent;\n              //console.log(accuracy)\n              accuracyInfo = {\n                name: \'accuracy\',\n                type: \'percent\',\n                value: accuracy\n              }; //console.log(accuracyInfo)\n              this.localConfig.modelEvaluations.push(accuracyInfo);\n            case 6:\n            case "end":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this);\n    }));\n    return function (_x5, _x6) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n});\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighborsMethodsShow.js\n\n\n//import {euclidean} from \'ml-distance-euclidean\'\nvar KNearestNeighborsMethodsShow_euclidean = __webpack_require__(415).euclidean;\n//const euclidean = MLDistanceEuclidean.euclidean\n\n/* harmony default export */ var KNearestNeighborsMethodsShow = (function (KNearestNeighbors) {\n  KNearestNeighbors.methods.showModel = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    var _this = this;\n    var unknownSetRowIndex, neighbors, neighborsID, unknowns, unknownsID, distanceMatrix, colorMatrix, tableHeaderUnknownColspan, tableHeader, trainSetClassesDict, unknownsPrediction, tableBody, bodyHTML, title, modelWindow;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (this.model) {\n              _context.next = 3;\n              break;\n            }\n            _context.next = 3;\n            return this.start();\n          case 3:\n            // --------------------------\n            //console.log(this.dataToShow)\n            unknownSetRowIndex = this.dataToShow.testSetRowIndexes;\n            neighbors = [];\n            neighborsID = [];\n            unknowns = [];\n            unknownsID = []; //console.log(unknownSetRowIndex)\n            this.dataToShow.testSet.forEach(function (set, i) {\n              if (unknownSetRowIndex.indexOf(i) === -1) {\n                neighbors.push(set);\n                neighborsID.push(i);\n              } else {\n                unknowns.push(set);\n                unknownsID.push(i);\n              }\n            });\n            if (unknowns.length === 0) {\n              unknowns = [].concat(neighbors);\n              unknownsID = [].concat(neighborsID);\n              unknownSetRowIndex = [].concat(neighborsID);\n            }\n\n            //console.log(neighbors)\n            // console.log(unknowns)\n            if (neighbors.length === 0) {\n              neighbors = unknowns;\n              neighborsID = unknownsID;\n            }\n\n            // --------------------------\n            distanceMatrix = unknowns.map(function (unknownFeature) {\n              var maxDistance = null;\n              var distances = neighbors.map(function (neighbor) {\n                var distance = KNearestNeighborsMethodsShow_euclidean(unknownFeature, neighbor);\n                if (maxDistance === null || distance > maxDistance) {\n                  maxDistance = distance;\n                }\n                return distance;\n              });\n              distances = distances.map(function (d) {\n                return (maxDistance - d) / maxDistance;\n              });\n              return distances;\n            }); // console.log(distanceMatrix)\n            if (!(distanceMatrix.length === 0)) {\n              _context.next = 14;\n              break;\n            }\n            throw Error(\'Distance matrix is empty\');\n          case 14:\n            colorMatrix = distanceMatrix.map(function (unknown) {\n              return unknown.map(function (d) {\n                return heatMapColorforValue(d);\n              });\n            }); //console.log(colorMatrix)\n            // --------------------------\n            tableHeaderUnknownColspan = 2;\n            if (this.model === \'unsupervised\') {\n              tableHeaderUnknownColspan = 1;\n            }\n\n            // console.log({tableHeaderUnknownColspan, colorMatrix})\n            tableHeader = "<thead>\\n  <tr>\\n    <th rowspan=\\"2\\" colspan=\\"".concat(tableHeaderUnknownColspan, "\\" valign=\\"bottom\\">").concat(this.$t(\'Unknowns\'), "</th>\\n    <th colspan=\\"").concat(colorMatrix[0].length, "\\">").concat(this.$t(\'Neighbors\'), "</th>\\n  </tr>\\n  <tr>").concat(colorMatrix[0].map(function (value, i) {\n              return "<th>".concat(neighborsID[i] + 1, "</th>");\n            }).join(\'\'), "</tr>\\n</thead>");\n            trainSetClassesDict = this.dataToShow.trainSetClassesDict;\n            unknownsPrediction = this.unknownsPrediction; // console.log({trainSetClassesDict, unknownsPrediction})\n            if (!(unknownsPrediction.length === 0)) {\n              _context.next = 26;\n              break;\n            }\n            _context.next = 23;\n            return this.$parent.getTrainSetPredictsResult();\n          case 23:\n            unknownsPrediction = _context.sent;\n            _context.next = 27;\n            break;\n          case 26:\n            unknownsPrediction = unknownsPrediction.map(function (i) {\n              return trainSetClassesDict[i];\n            });\n          case 27:\n            tableBody = "<tbody>\\n".concat(colorMatrix.map(function (row, i) {\n              var thPrediection = "<th>".concat(unknownsPrediction[i], "</th>");\n              if (_this.model === \'unsupervised\') {\n                thPrediection = \'\';\n              }\n              return "<tr>\\n  <th>".concat(unknownSetRowIndex[i] + 1, "</th>\\n  ").concat(thPrediection, "\\n  ").concat(row.map(function (color, j) {\n                var d = distanceMatrix[i][j];\n                var dText = d;\n                dText = Math.round(dText * 100) + \'%\';\n                if (d > 0.7 || d < 0.3) {\n                  return "<td style=\\"text-align:center;background-color: ".concat(color, "; color: white\\">").concat(dText, "</td>");\n                } else {\n                  return "<td style=\\"text-align:center;background-color: ".concat(color, "\\">").concat(dText, "</td>");\n                }\n              }).join(\'\'), "\\n</tr>");\n            }).join(\'\\n\'), "\\n</tbody>"); // --------------------------\n            // console.log(tableBody)\n            bodyHTML = "<table border=\\"1\\" align=\\"center\\">\\n    ".concat(tableHeader, "\\n    ").concat(tableBody, "\\n</table>");\n            bodyHTML = "<div class=\\"tree\\">".concat(bodyHTML, "</div>");\n            //console.error(\'[TODO]\')\n            //console.log()\n            title = this.$t(\'KNN\') + " (" + new Date().mmddhhmm() + \')\'; // console.log(\'KNNModelShow\' + this.config.modelBuildedTime)\n            modelWindow = this.utils.PopupUtils.open({\n              windowName: \'KNNModelShow\' + this.config.modelBuildedTime,\n              cssURL: this.modelCSSURL,\n              bodyHTML: bodyHTML,\n              size: \'right\',\n              //size: \'left\',\n              title: title\n            });\n            modelWindow.scrollToTop();\n            modelWindow.scrollToCenter();\n          case 34:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  /**\n   * https://stackoverflow.com/a/27263918/6645399\n   */\n  function heatMapColorforValue(value) {\n    var h = (1.0 - value) * 240;\n    return "hsl(" + h + ", 100%, 50%)";\n    //return `rgba(22, 160, 133, ${value})`\n    // rgb(22, 160, 133)\n  }\n});\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighborsMethodsTest.js\n\n\n\n// https://www.npmjs.com/package/ml-knn\n\n/* harmony default export */ var KNearestNeighborsMethodsTest = (function (KNearestNeighbors) {\n  KNearestNeighbors.methods.testKNN = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    var dataset, predictions, knn, ans;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            dataset = [[0, 0, 0], [0, 1, 1], [1, 1, 0], [2, 2, 2], [1, 2, 2], [2, 1, 2]];\n            predictions = [0, 0, 0, 1, 1, 1];\n            knn = new src_KNN(dataset, predictions);\n            dataset = [[0, 0, 0], [2, 2, 2]];\n            ans = knn.predict(dataset);\n            console.log(ans);\n          case 6:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n});\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--6!./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.js?vue&type=script&lang=js&\nvar KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors = {\n  props: [\'config\', \'localConfig\', \'utils\'],\n  data: function data() {\n    this.$i18n.locale = this.localConfig.locale;\n    return {\n      model: null,\n      dataToShow: null,\n      unknownsPrediction: []\n    };\n  },\n  watch: {\n    \'localConfig.locale\': function localConfigLocale() {\n      this.$i18n.locale = this.localConfig.locale;\n    },\n    \'localConfig.KNearestNeighborsOptionsK\': function localConfigKNearestNeighborsOptionsK() {\n      this.$parent.clearPrediction();\n    }\n  },\n  computed: {\n    isModelBuilded: function isModelBuilded() {\n      return this.model !== null;\n    },\n    isModelUnsupervised: function isModelUnsupervised() {\n      return this.model !== null && this.model === \'unsupervised\';\n    }\n  },\n  mounted: function mounted() {\n    //    setTimeout(() => {\n    //      this.start()\n    //    }, 1000)\n\n    //this.testKNN()\n  },\n  methods: {}\n};\n\nKNearestNeighborsMethodsBuild(KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n\nKNearestNeighborsMethodsShow(KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n\nKNearestNeighborsMethodsTest(KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n/* harmony default export */ var KNearestNeighborsvue_type_script_lang_js_ = (KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.js?vue&type=script&lang=js&\n /* harmony default export */ var KNearestNeighbors_KNearestNeighborsvue_type_script_lang_js_ = (KNearestNeighborsvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.less?vue&type=style&index=0&id=5cdf9f80&prod&lang=less&scoped=true&\nvar KNearestNeighborsvue_type_style_index_0_id_5cdf9f80_prod_lang_less_scoped_true_ = __webpack_require__(545);\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FConfigurationPanel%2FKNearestNeighbors%2FKNearestNeighbors.vue&lang=yaml\nvar KNearestNeighborsvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml = __webpack_require__(547);\n\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  KNearestNeighbors_KNearestNeighborsvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "5cdf9f80",\n  null\n  \n)\n\n/* custom blocks */\n\nif (typeof KNearestNeighborsvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml["default"] === \'function\') Object(KNearestNeighborsvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml["default"])(component)\n\n/* harmony default export */ var KNearestNeighbors_KNearestNeighbors = __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmh0bWw/N2VlOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwta25uL3NyYy9LRFRyZWUuanM/OWQwYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwta25uL3NyYy9pbmRleC5qcz8yNjEyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NvbmZpZ3VyYXRpb25QYW5lbC9LTmVhcmVzdE5laWdoYm9ycy9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNCdWlsZC5qcz8zMWM0Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NvbmZpZ3VyYXRpb25QYW5lbC9LTmVhcmVzdE5laWdoYm9ycy9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNTaG93LmpzPzNkYjciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Rlc3QuanM/NTU0NiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMuanM/ZmFiMiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMuanM/ZjAxNiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMudnVlP2RkODMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgdmFyIF92bSA9IHRoaXMsXG4gICAgX2MgPSBfdm0uX3NlbGYuX2NcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiRGVjaXNpb25UcmVlXCIgfSwgW1xuICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZmllbGRcIiB9LCBbXG4gICAgICBfYyhcImxhYmVsXCIsIHsgYXR0cnM6IHsgZm9yOiBcIktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0tcIiB9IH0sIFtcbiAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uJHQoXCJLLW5lYXJlc3QgbmVpZ2hib3JcIikpKSxcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLmxvY2FsQ29uZmlnLktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0ssXG4gICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0tcIixcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBhdHRyczogeyB0eXBlOiBcIm51bWJlclwiLCBtaW46IFwiMlwiLCBpZDogXCJLTmVhcmVzdE5laWdoYm9yc09wdGlvbnNLXCIgfSxcbiAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5LTmVhcmVzdE5laWdoYm9yc09wdGlvbnNLIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykgcmV0dXJuXG4gICAgICAgICAgICBfdm0uJHNldChcbiAgICAgICAgICAgICAgX3ZtLmxvY2FsQ29uZmlnLFxuICAgICAgICAgICAgICBcIktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0tcIixcbiAgICAgICAgICAgICAgJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdKSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgICFfdm0uaXNNb2RlbEJ1aWxkZWRcbiAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ1aSBmaWVsZFwiIH0sIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInVpIHByaW1hcnkgZmx1aWQgYnV0dG9uXCIsXG4gICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5zdGFydCB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgIFwiXFxyXFxuICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0uJHQoXCJCdWlsZCBNb2RlbCBhbmQgUHJlZGljdFwiKSkgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcclxcbiAgICAgIFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKSxcbiAgICAgICAgXSlcbiAgICAgIDogX3ZtLl9lKCksXG4gICAgX3ZtLl92KFwiIFwiKSxcbiAgICBfdm0uaXNNb2RlbEJ1aWxkZWQgJiYgIV92bS5pc01vZGVsVW5zdXBlcnZpc2VkXG4gICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidWkgZmllbGRcIiB9LCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ1aSBwcmltYXJ5IGZsdWlkIGJ1dHRvblwiLFxuICAgICAgICAgICAgICBjbGFzczogeyBkaXNhYmxlZDogIV92bS4kcGFyZW50LmlzTmVlZFByZWRpY3QgfSxcbiAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnN0YXJ0IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgXCJcXHJcXG4gICAgICAgIFwiICsgX3ZtLl9zKF92bS4kdChcIlByZWRpY3RcIikpICsgXCJcXHJcXG4gICAgICBcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMlxuICAgICAgICAgICksXG4gICAgICAgIF0pXG4gICAgICA6IF92bS5fZSgpLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX3ZtLmlzTW9kZWxCdWlsZGVkXG4gICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidWkgZmllbGRcIiB9LCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ1aSBwcmltYXJ5IGZsdWlkIGJ1dHRvblwiLFxuICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uc2hvd01vZGVsIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW192bS5fdihcIlxcclxcbiAgICAgIFwiICsgX3ZtLl9zKF92bS4kdChcIlNob3cgTW9kZWxcIikpICsgXCJcXHJcXG4gICAgXCIpXVxuICAgICAgICAgICksXG4gICAgICAgIF0pXG4gICAgICA6IF92bS5fZSgpLFxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIi8qXG4gKiBPcmlnaW5hbCBjb2RlIGZyb206XG4gKlxuICogay1kIFRyZWUgSmF2YVNjcmlwdCAtIFYgMS4wMVxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS91YmlsYWJzL2tkLXRyZWUtamF2YXNjcmlwdFxuICpcbiAqIEBhdXRob3IgTWlyY2VhIFByaWNvcCA8cHJpY29wQHViaWxhYnMubmV0PiwgMjAxMlxuICogQGF1dGhvciBNYXJ0aW4gS2xlcHBlIDxrbGVwcGVAdWJpbGFicy5uZXQ+LCAyMDEyXG4gKiBAYXV0aG9yIFViaWxhYnMgaHR0cDovL3ViaWxhYnMubmV0LCAyMDEyXG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSA8aHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHA+XG4gKi9cblxuZnVuY3Rpb24gTm9kZShvYmosIGRpbWVuc2lvbiwgcGFyZW50KSB7XG4gIHRoaXMub2JqID0gb2JqO1xuICB0aGlzLmxlZnQgPSBudWxsO1xuICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLRFRyZWUge1xuICBjb25zdHJ1Y3Rvcihwb2ludHMsIG1ldHJpYykge1xuICAgIC8vIElmIHBvaW50cyBpcyBub3QgYW4gYXJyYXksIGFzc3VtZSB3ZSdyZSBsb2FkaW5nIGEgcHJlLWJ1aWx0IHRyZWVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0gcG9pbnRzLmRpbWVuc2lvbnM7XG4gICAgICB0aGlzLnJvb3QgPSBwb2ludHM7XG4gICAgICByZXN0b3JlUGFyZW50KHRoaXMucm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBBcnJheShwb2ludHNbMF0ubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc1tpXSA9IGk7XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QgPSBidWlsZFRyZWUocG9pbnRzLCAwLCBudWxsLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIH1cbiAgICB0aGlzLm1ldHJpYyA9IG1ldHJpYztcbiAgfVxuXG4gIC8vIENvbnZlcnQgdG8gYSBKU09OIHNlcmlhbGl6YWJsZSBzdHJ1Y3R1cmU7IHRoaXMganVzdCByZXF1aXJlcyByZW1vdmluZ1xuICAvLyB0aGUgYHBhcmVudGAgcHJvcGVydHlcbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRvSlNPTkltcGwodGhpcy5yb290LCB0cnVlKTtcbiAgICByZXN1bHQuZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgbmVhcmVzdChwb2ludCwgbWF4Tm9kZXMsIG1heERpc3RhbmNlKSB7XG4gICAgY29uc3QgbWV0cmljID0gdGhpcy5tZXRyaWM7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICB2YXIgaTtcblxuICAgIGNvbnN0IGJlc3ROb2RlcyA9IG5ldyBCaW5hcnlIZWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gLWVbMV07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBuZWFyZXN0U2VhcmNoKG5vZGUpIHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGRpbWVuc2lvbnNbbm9kZS5kaW1lbnNpb25dO1xuICAgICAgY29uc3Qgb3duRGlzdGFuY2UgPSBtZXRyaWMocG9pbnQsIG5vZGUub2JqKTtcbiAgICAgIGNvbnN0IGxpbmVhclBvaW50ID0ge307XG4gICAgICB2YXIgYmVzdENoaWxkLCBsaW5lYXJEaXN0YW5jZSwgb3RoZXJDaGlsZCwgaTtcblxuICAgICAgZnVuY3Rpb24gc2F2ZU5vZGUobm9kZSwgZGlzdGFuY2UpIHtcbiAgICAgICAgYmVzdE5vZGVzLnB1c2goW25vZGUsIGRpc3RhbmNlXSk7XG4gICAgICAgIGlmIChiZXN0Tm9kZXMuc2l6ZSgpID4gbWF4Tm9kZXMpIHtcbiAgICAgICAgICBiZXN0Tm9kZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPT09IG5vZGUuZGltZW5zaW9uKSB7XG4gICAgICAgICAgbGluZWFyUG9pbnRbZGltZW5zaW9uc1tpXV0gPSBwb2ludFtkaW1lbnNpb25zW2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lYXJQb2ludFtkaW1lbnNpb25zW2ldXSA9IG5vZGUub2JqW2RpbWVuc2lvbnNbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbmVhckRpc3RhbmNlID0gbWV0cmljKGxpbmVhclBvaW50LCBub2RlLm9iaik7XG5cbiAgICAgIGlmIChub2RlLnJpZ2h0ID09PSBudWxsICYmIG5vZGUubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoYmVzdE5vZGVzLnNpemUoKSA8IG1heE5vZGVzIHx8IG93bkRpc3RhbmNlIDwgYmVzdE5vZGVzLnBlZWsoKVsxXSkge1xuICAgICAgICAgIHNhdmVOb2RlKG5vZGUsIG93bkRpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgIGJlc3RDaGlsZCA9IG5vZGUubGVmdDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIGJlc3RDaGlsZCA9IG5vZGUucmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocG9pbnRbZGltZW5zaW9uXSA8IG5vZGUub2JqW2RpbWVuc2lvbl0pIHtcbiAgICAgICAgICBiZXN0Q2hpbGQgPSBub2RlLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmVzdENoaWxkID0gbm9kZS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZWFyZXN0U2VhcmNoKGJlc3RDaGlsZCk7XG5cbiAgICAgIGlmIChiZXN0Tm9kZXMuc2l6ZSgpIDwgbWF4Tm9kZXMgfHwgb3duRGlzdGFuY2UgPCBiZXN0Tm9kZXMucGVlaygpWzFdKSB7XG4gICAgICAgIHNhdmVOb2RlKG5vZGUsIG93bkRpc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBiZXN0Tm9kZXMuc2l6ZSgpIDwgbWF4Tm9kZXMgfHxcbiAgICAgICAgTWF0aC5hYnMobGluZWFyRGlzdGFuY2UpIDwgYmVzdE5vZGVzLnBlZWsoKVsxXVxuICAgICAgKSB7XG4gICAgICAgIGlmIChiZXN0Q2hpbGQgPT09IG5vZGUubGVmdCkge1xuICAgICAgICAgIG90aGVyQ2hpbGQgPSBub2RlLnJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyQ2hpbGQgPSBub2RlLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBuZWFyZXN0U2VhcmNoKG90aGVyQ2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heERpc3RhbmNlKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWF4Tm9kZXM7IGkgKz0gMSkge1xuICAgICAgICBiZXN0Tm9kZXMucHVzaChbbnVsbCwgbWF4RGlzdGFuY2VdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICBuZWFyZXN0U2VhcmNoKHRoaXMucm9vdCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IE1hdGgubWluKG1heE5vZGVzLCBiZXN0Tm9kZXMuY29udGVudC5sZW5ndGgpOyBpICs9IDEpIHtcbiAgICAgIGlmIChiZXN0Tm9kZXMuY29udGVudFtpXVswXSkge1xuICAgICAgICByZXN1bHQucHVzaChbYmVzdE5vZGVzLmNvbnRlbnRbaV1bMF0ub2JqLCBiZXN0Tm9kZXMuY29udGVudFtpXVsxXV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvSlNPTkltcGwoc3JjKSB7XG4gIGNvbnN0IGRlc3QgPSBuZXcgTm9kZShzcmMub2JqLCBzcmMuZGltZW5zaW9uLCBudWxsKTtcbiAgaWYgKHNyYy5sZWZ0KSBkZXN0LmxlZnQgPSB0b0pTT05JbXBsKHNyYy5sZWZ0KTtcbiAgaWYgKHNyYy5yaWdodCkgZGVzdC5yaWdodCA9IHRvSlNPTkltcGwoc3JjLnJpZ2h0KTtcbiAgcmV0dXJuIGRlc3Q7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShwb2ludHMsIGRlcHRoLCBwYXJlbnQsIGRpbWVuc2lvbnMpIHtcbiAgY29uc3QgZGltID0gZGVwdGggJSBkaW1lbnNpb25zLmxlbmd0aDtcblxuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHBvaW50c1swXSwgZGltLCBwYXJlbnQpO1xuICB9XG5cbiAgcG9pbnRzLnNvcnQoKGEsIGIpID0+IGFbZGltZW5zaW9uc1tkaW1dXSAtIGJbZGltZW5zaW9uc1tkaW1dXSk7XG5cbiAgY29uc3QgbWVkaWFuID0gTWF0aC5mbG9vcihwb2ludHMubGVuZ3RoIC8gMik7XG4gIGNvbnN0IG5vZGUgPSBuZXcgTm9kZShwb2ludHNbbWVkaWFuXSwgZGltLCBwYXJlbnQpO1xuICBub2RlLmxlZnQgPSBidWlsZFRyZWUocG9pbnRzLnNsaWNlKDAsIG1lZGlhbiksIGRlcHRoICsgMSwgbm9kZSwgZGltZW5zaW9ucyk7XG4gIG5vZGUucmlnaHQgPSBidWlsZFRyZWUocG9pbnRzLnNsaWNlKG1lZGlhbiArIDEpLCBkZXB0aCArIDEsIG5vZGUsIGRpbWVuc2lvbnMpO1xuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlUGFyZW50KHJvb3QpIHtcbiAgaWYgKHJvb3QubGVmdCkge1xuICAgIHJvb3QubGVmdC5wYXJlbnQgPSByb290O1xuICAgIHJlc3RvcmVQYXJlbnQocm9vdC5sZWZ0KTtcbiAgfVxuXG4gIGlmIChyb290LnJpZ2h0KSB7XG4gICAgcm9vdC5yaWdodC5wYXJlbnQgPSByb290O1xuICAgIHJlc3RvcmVQYXJlbnQocm9vdC5yaWdodCk7XG4gIH1cbn1cblxuLy8gQmluYXJ5IGhlYXAgaW1wbGVtZW50YXRpb24gZnJvbTpcbi8vIGh0dHA6Ly9lbG9xdWVudGphdmFzY3JpcHQubmV0L2FwcGVuZGl4Mi5odG1sXG5jbGFzcyBCaW5hcnlIZWFwIHtcbiAgY29uc3RydWN0b3Ioc2NvcmVGdW5jdGlvbikge1xuICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgIHRoaXMuc2NvcmVGdW5jdGlvbiA9IHNjb3JlRnVuY3Rpb247XG4gIH1cblxuICBwdXNoKGVsZW1lbnQpIHtcbiAgICAvLyBBZGQgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHRoaXMuY29udGVudC5wdXNoKGVsZW1lbnQpO1xuICAgIC8vIEFsbG93IGl0IHRvIGJ1YmJsZSB1cC5cbiAgICB0aGlzLmJ1YmJsZVVwKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHBvcCgpIHtcbiAgICAvLyBTdG9yZSB0aGUgZmlyc3QgZWxlbWVudCBzbyB3ZSBjYW4gcmV0dXJuIGl0IGxhdGVyLlxuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XG4gICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxuICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IHNpbmsgZG93bi5cbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29udGVudFswXSA9IGVuZDtcbiAgICAgIHRoaXMuc2lua0Rvd24oMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbMF07XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICB9XG5cbiAgYnViYmxlVXAobikge1xuICAgIC8vIEZldGNoIHRoZSBlbGVtZW50IHRoYXQgaGFzIHRvIGJlIG1vdmVkLlxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dO1xuICAgIC8vIFdoZW4gYXQgMCwgYW4gZWxlbWVudCBjYW4gbm90IGdvIHVwIGFueSBmdXJ0aGVyLlxuICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgY29uc3QgcGFyZW50TiA9IE1hdGguZmxvb3IoKG4gKyAxKSAvIDIpIC0gMTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuY29udGVudFtwYXJlbnROXTtcbiAgICAgIC8vIFN3YXAgdGhlIGVsZW1lbnRzIGlmIHRoZSBwYXJlbnQgaXMgZ3JlYXRlci5cbiAgICAgIGlmICh0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkge1xuICAgICAgICB0aGlzLmNvbnRlbnRbcGFyZW50Tl0gPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XG4gICAgICAgIC8vIFVwZGF0ZSAnbicgdG8gY29udGludWUgYXQgdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgbiA9IHBhcmVudE47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3VuZCBhIHBhcmVudCB0aGF0IGlzIGxlc3MsIG5vIG5lZWQgdG8gbW92ZSBpdCBmdXJ0aGVyLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzaW5rRG93bihuKSB7XG4gICAgLy8gTG9vayB1cCB0aGUgdGFyZ2V0IGVsZW1lbnQgYW5kIGl0cyBzY29yZS5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXTtcbiAgICB2YXIgZWxlbVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIGluZGljZXMgb2YgdGhlIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpICogMjtcbiAgICAgIHZhciBjaGlsZDFOID0gY2hpbGQyTiAtIDE7XG4gICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCxcbiAgICAgIC8vIGlmIGFueS5cbiAgICAgIHZhciBzd2FwID0gbnVsbDtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXG4gICAgICBpZiAoY2hpbGQxTiA8IGxlbmd0aCkge1xuICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cbiAgICAgICAgdmFyIGNoaWxkMSA9IHRoaXMuY29udGVudFtjaGlsZDFOXTtcbiAgICAgICAgdmFyIGNoaWxkMVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMSk7XG4gICAgICAgIC8vIElmIHRoZSBzY29yZSBpcyBsZXNzIHRoYW4gb3VyIGVsZW1lbnQncywgd2UgbmVlZCB0byBzd2FwLlxuICAgICAgICBpZiAoY2hpbGQxU2NvcmUgPCBlbGVtU2NvcmUpIHtcbiAgICAgICAgICBzd2FwID0gY2hpbGQxTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG8gdGhlIHNhbWUgY2hlY2tzIGZvciB0aGUgb3RoZXIgY2hpbGQuXG4gICAgICBpZiAoY2hpbGQyTiA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgY2hpbGQyID0gdGhpcy5jb250ZW50W2NoaWxkMk5dO1xuICAgICAgICB2YXIgY2hpbGQyU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQyKTtcbiAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT09IG51bGwgPyBlbGVtU2NvcmUgOiBjaGlsZDFTY29yZSkpIHtcbiAgICAgICAgICBzd2FwID0gY2hpbGQyTjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBuZWVkcyB0byBiZSBtb3ZlZCwgc3dhcCBpdCwgYW5kIGNvbnRpbnVlLlxuICAgICAgaWYgKHN3YXAgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50W25dID0gdGhpcy5jb250ZW50W3N3YXBdO1xuICAgICAgICB0aGlzLmNvbnRlbnRbc3dhcF0gPSBlbGVtZW50O1xuICAgICAgICBuID0gc3dhcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgYXJlIGRvbmUuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIGFzIGV1Y2xpZGVhbkRpc3RhbmNlIH0gZnJvbSAnbWwtZGlzdGFuY2UtZXVjbGlkZWFuJztcblxuaW1wb3J0IEtEVHJlZSBmcm9tICcuL0tEVHJlZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtOTiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGxhYmVsc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaz1udW1iZXJPZkNsYXNzZXMgKyAxXSAtIE51bWJlciBvZiBuZWlnaGJvcnMgdG8gY2xhc3NpZnkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmRpc3RhbmNlPWV1Y2xpZGVhbkRpc3RhbmNlXSAtIERpc3RhbmNlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdHdvIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhc2V0LCBsYWJlbHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChkYXRhc2V0ID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBtb2RlbCA9IGxhYmVscztcbiAgICAgIHRoaXMua2RUcmVlID0gbmV3IEtEVHJlZShtb2RlbC5rZFRyZWUsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5rID0gbW9kZWwuaztcbiAgICAgIHRoaXMuY2xhc3NlcyA9IG5ldyBTZXQobW9kZWwuY2xhc3Nlcyk7XG4gICAgICB0aGlzLmlzRXVjbGlkZWFuID0gbW9kZWwuaXNFdWNsaWRlYW47XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NlcyA9IG5ldyBTZXQobGFiZWxzKTtcblxuICAgIGNvbnN0IHsgZGlzdGFuY2UgPSBldWNsaWRlYW5EaXN0YW5jZSwgayA9IGNsYXNzZXMuc2l6ZSArIDEgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkoZGF0YXNldC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwb2ludHNbaV0gPSBkYXRhc2V0W2ldLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgcG9pbnRzW2ldLnB1c2gobGFiZWxzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLmtkVHJlZSA9IG5ldyBLRFRyZWUocG9pbnRzLCBkaXN0YW5jZSk7XG4gICAgdGhpcy5rID0gaztcbiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzO1xuICAgIHRoaXMuaXNFdWNsaWRlYW4gPSBkaXN0YW5jZSA9PT0gZXVjbGlkZWFuRGlzdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEtOTiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBtb2RlbC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpc3RhbmNlPWV1Y2xpZGVhbkRpc3RhbmNlIC0gZGlzdGFuY2UgZnVuY3Rpb24gbXVzdCBiZSBwcm92aWRlZCBpZiB0aGUgbW9kZWwgd2Fzbid0IHRyYWluZWQgd2l0aCBldWNsaWRlYW4gZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge0tOTn1cbiAgICovXG4gIHN0YXRpYyBsb2FkKG1vZGVsLCBkaXN0YW5jZSA9IGV1Y2xpZGVhbkRpc3RhbmNlKSB7XG4gICAgaWYgKG1vZGVsLm5hbWUgIT09ICdLTk4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbW9kZWw6ICR7bW9kZWwubmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKCFtb2RlbC5pc0V1Y2xpZGVhbiAmJiBkaXN0YW5jZSA9PT0gZXVjbGlkZWFuRGlzdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2EgY3VzdG9tIGRpc3RhbmNlIGZ1bmN0aW9uIHdhcyB1c2VkIHRvIGNyZWF0ZSB0aGUgbW9kZWwuIFBsZWFzZSBwcm92aWRlIGl0IGFnYWluJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1vZGVsLmlzRXVjbGlkZWFuICYmIGRpc3RhbmNlICE9PSBldWNsaWRlYW5EaXN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndGhlIG1vZGVsIHdhcyBjcmVhdGVkIHdpdGggdGhlIGRlZmF1bHQgZGlzdGFuY2UgZnVuY3Rpb24uIERvIG5vdCBsb2FkIGl0IHdpdGggYW5vdGhlciBvbmUnXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEtOTih0cnVlLCBtb2RlbCwgZGlzdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIEpTT04gY29udGFpbmluZyB0aGUga2QtdHJlZSBtb2RlbC5cbiAgICogQHJldHVybiB7b2JqZWN0fSBKU09OIEtOTiBtb2RlbC5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ0tOTicsXG4gICAgICBrZFRyZWU6IHRoaXMua2RUcmVlLFxuICAgICAgazogdGhpcy5rLFxuICAgICAgY2xhc3NlczogQXJyYXkuZnJvbSh0aGlzLmNsYXNzZXMpLFxuICAgICAgaXNFdWNsaWRlYW46IHRoaXMuaXNFdWNsaWRlYW5cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFByZWRpY3RzIHRoZSBvdXRwdXQgZ2l2ZW4gdGhlIG1hdHJpeCB0byBwcmVkaWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhc2V0XG4gICAqIEByZXR1cm4ge0FycmF5fSBwcmVkaWN0aW9uc1xuICAgKi9cbiAgcHJlZGljdChkYXRhc2V0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YXNldCkpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldFswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpbmdsZVByZWRpY3Rpb24odGhpcywgZGF0YXNldCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KGRhdGFzZXRbMF0pICYmXG4gICAgICAgIHR5cGVvZiBkYXRhc2V0WzBdWzBdID09PSAnbnVtYmVyJ1xuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb25zID0gbmV3IEFycmF5KGRhdGFzZXQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcHJlZGljdGlvbnNbaV0gPSBnZXRTaW5nbGVQcmVkaWN0aW9uKHRoaXMsIGRhdGFzZXRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVkaWN0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YXNldCB0byBwcmVkaWN0IG11c3QgYmUgYW4gYXJyYXkgb3IgYSBtYXRyaXgnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTaW5nbGVQcmVkaWN0aW9uKGtubiwgY3VycmVudENhc2UpIHtcbiAgdmFyIG5lYXJlc3RQb2ludHMgPSBrbm4ua2RUcmVlLm5lYXJlc3QoY3VycmVudENhc2UsIGtubi5rKTtcbiAgdmFyIHBvaW50c1BlckNsYXNzID0ge307XG4gIHZhciBwcmVkaWN0ZWRDbGFzcyA9IC0xO1xuICB2YXIgbWF4UG9pbnRzID0gLTE7XG4gIHZhciBsYXN0RWxlbWVudCA9IG5lYXJlc3RQb2ludHNbMF1bMF0ubGVuZ3RoIC0gMTtcblxuICBmb3IgKHZhciBlbGVtZW50IG9mIGtubi5jbGFzc2VzKSB7XG4gICAgcG9pbnRzUGVyQ2xhc3NbZWxlbWVudF0gPSAwO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWFyZXN0UG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGN1cnJlbnRDbGFzcyA9IG5lYXJlc3RQb2ludHNbaV1bMF1bbGFzdEVsZW1lbnRdO1xuICAgIHZhciBjdXJyZW50UG9pbnRzID0gKytwb2ludHNQZXJDbGFzc1tjdXJyZW50Q2xhc3NdO1xuICAgIGlmIChjdXJyZW50UG9pbnRzID4gbWF4UG9pbnRzKSB7XG4gICAgICBwcmVkaWN0ZWRDbGFzcyA9IGN1cnJlbnRDbGFzcztcbiAgICAgIG1heFBvaW50cyA9IGN1cnJlbnRQb2ludHM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZWRpY3RlZENsYXNzO1xufVxuIiwiaW1wb3J0IEtOTiBmcm9tICdtbC1rbm4nXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoS05lYXJlc3ROZWlnaGJvcnMpIHtcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLnN0YXJ0UHJlZGljdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0KClcclxuICB9XHJcbiAgICBcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLnN0YXJ0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgLy90aGlzLmxvY2FsQ29uZmlnLm1vZGVsSlNPTiA9IG51bGxcclxuICAgIHRoaXMuY29uZmlnLmxvYWRpbmdQcm9ncmVzcyA9IDBcclxuICAgIC8vIGNvbnNvbGUubG9nKCdzdGFydCcsIDEpXHJcbiAgICBcclxuICAgIHRoaXMubG9jYWxDb25maWcubW9kZWxKU09OID0gbnVsbFxyXG4gICAgdGhpcy5sb2NhbENvbmZpZy5tb2RlbEV2YWx1YXRpb25zID0gW11cclxuICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy4kcGFyZW50LmdldFZlY3RvckRhdGEoKVxyXG4gICAgXHJcbiAgICB0aGlzLmRhdGFUb1Nob3cgPSBkYXRhXHJcbiAgICBcclxuICAgIGlmIChkYXRhLnRyYWluU2V0Q2xhc3Nlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTm8gdHJhaW5TZXRDbGFzc2VzJylcclxuICAgICAgLy90aHJvdyBFcnJvcignTm8gdHJhaW5TZXRDbGFzc2VzJylcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gY29uc29sZS5sb2coZGF0YSlcclxuICAgIC8vcmV0dXJuIGZhbHNlXHJcbiAgICB0aGlzLmNvbmZpZy5sb2FkaW5nUHJvZ3Jlc3MgPSAwLjI1XHJcbiAgICBcclxuICAgIC8vIGNvbnNvbGUubG9nKCdzdGFydCcsIDIpXHJcbiAgICAvL2NvbnNvbGUubG9nKGRhdGEudHJhaW5TZXRbMF0pXHJcbiAgICBcclxuICAgIC8vIGNvbnNvbGUubG9nKCdzdGFydCcsIDMpXHJcbiAgICBpZiAoZGF0YS50cmFpblNldENsYXNzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBpZiAoIXRoaXMubG9jYWxDb25maWcubW9kZWxKU09OKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuYnVpbGRNb2RlbChkYXRhKVxyXG4gICAgICAgIHRoaXMubG9jYWxDb25maWcubW9kZWxKU09OID0gdGhpcy5tb2RlbFxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBLTk4ubG9hZCh0aGlzLmxvY2FsQ29uZmlnLm1vZGVsSlNPTilcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm1vZGVsLnRvSlNPTigpKVxyXG5cclxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm1vZGVsKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZygnc3RhcnQnLCA1KVxyXG5cclxuICAgICAgdGhpcy5jb25maWcubG9hZGluZ1Byb2dyZXNzID0gMC41XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZygnc3RhcnQnLCA5KVxyXG4gICAgICAvL2NvbnNvbGUubG9nKGRhdGEudGVzdFNldClcclxuICAgICAgbGV0IHByZWRpY3RWZWN0b3IgPSBhd2FpdCB0aGlzLmdldFByZWRpY3RSZXN1bHRzVmVjdG9yKHRoaXMubW9kZWwsIGRhdGEpXHJcbiAgICAgIGxldCBwcmVkaWN0UmVzdWx0cyA9IGF3YWl0IHRoaXMuZ2V0UHJlZGljdFJlc3VsdHNWYWx1ZShkYXRhLCBwcmVkaWN0VmVjdG9yKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhwcmVkaWN0VmVjdG9yKVxyXG4gICAgICBpZiAocHJlZGljdFJlc3VsdHNbMF0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcubG9hZGluZ1Byb2dyZXNzID0gMVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3ByZWRpY3QgaXMgdW5kZWZpbmVkJylcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2coJ3N0YXJ0JywgMTApXHJcbiAgICAgIHRoaXMuY29uZmlnLmxvYWRpbmdQcm9ncmVzcyA9IDAuNzVcclxuXHJcbiAgICAgIGlmICh0aGlzLiRwYXJlbnQuaGFzTW9kZWxFdmFsdWF0ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IHRlc3RTZXRSb3dJbmRleGVzID0gZGF0YS50ZXN0U2V0Um93SW5kZXhlc1xyXG4gICAgICAgIHRoaXMudW5rbm93bnNQcmVkaWN0aW9uID0gW11cclxuICAgICAgICBsZXQgcHJlZGljdFZlY3RvclRvRXZhbHV0ZSA9IHByZWRpY3RWZWN0b3IuZmlsdGVyKCh2YWx1ZSwgaSkgPT4ge1xyXG4gICAgICAgICAgbGV0IG5vdE1hdGNoID0gKHRlc3RTZXRSb3dJbmRleGVzLmluZGV4T2YoaSkgPT09IC0xKVxyXG5cclxuICAgICAgICAgIGlmIChub3RNYXRjaCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy51bmtub3duc1ByZWRpY3Rpb24ucHVzaCh2YWx1ZSlcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gbm90TWF0Y2hcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuZXZhbHVhdGlvblJlc3VsdHMoZGF0YS50cmFpblNldENsYXNzZXMsIHByZWRpY3RWZWN0b3JUb0V2YWx1dGUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vY29uc29sZS5sb2cocHJlZGljdFJlc3VsdHMpXHJcbiAgICAgIHRoaXMuJHBhcmVudC5zZXRQcmVkaWN0UmVzdWx0cyhwcmVkaWN0UmVzdWx0cylcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnLmxvYWRpbmdQcm9ncmVzcyA9IDAuOVxyXG5cclxuICAgIH0gLy8gaWYgKGRhdGEudHJhaW5TZXRDbGFzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGlzLm1vZGVsID0gJ3Vuc3VwZXJ2aXNlZCdcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuJHBhcmVudC5pc01vZGVsV2luZG93T3BlbmVkKSB7XHJcbiAgICAgIHRoaXMuc2hvd01vZGVsKClcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5jb25maWcubG9hZGluZ1Byb2dyZXNzID0gMVxyXG4gICAgdGhpcy5jb25maWcubW9kZWxCdWlsZGVkVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKClcclxuICB9XHJcbiAgXHJcbiAgS05lYXJlc3ROZWlnaGJvcnMubWV0aG9kcy5idWlsZE1vZGVsID0gZnVuY3Rpb24gKGRhdGEpe1xyXG4gICAgbGV0IHRlc3RTZXRSb3dJbmRleGVzID0gZGF0YS50ZXN0U2V0Um93SW5kZXhlc1xyXG4gICAgbGV0IGRhdGFzZXQgPSBkYXRhLnRlc3RTZXQuZmlsdGVyKChyb3csIGkpID0+IHtcclxuICAgICAgcmV0dXJuICh0ZXN0U2V0Um93SW5kZXhlcy5pbmRleE9mKGkpID09PSAtMSlcclxuICAgIH0pXHJcbiAgICBcclxuICAgIC8vIGNvbnNvbGUubG9nKGRhdGFzZXQpXHJcbiAgICBsZXQgcHJlZGljdGlvbnMgPSBkYXRhLnRyYWluU2V0Q2xhc3Nlc1xyXG4gICAgXHJcbiAgICBpZiAoZGF0YXNldC5sZW5ndGggPT09IDApIHtcclxuICAgICAgZGF0YXNldCA9IGRhdGEudGVzdFNldFxyXG4gICAgICBwcmVkaWN0aW9ucyA9IGRhdGFzZXQubWFwKGl0ZW0gPT4gJ3Vua25vd24nKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoZGF0YXNldC5sZW5ndGggIT09IHByZWRpY3Rpb25zLmxlbmd0aCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdsZW5ndGggaXMgbm90IG1hdGNoJylcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBLTk4oZGF0YXNldCwgcHJlZGljdGlvbnMsIHtcclxuICAgICAgazogdGhpcy5sb2NhbENvbmZpZy5LTmVhcmVzdE5laWdoYm9yc09wdGlvbnNLXHJcbiAgICB9KVxyXG4gIH1cclxuICBcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLmdldFByZWRpY3RSZXN1bHRzVmVjdG9yID0gYXN5bmMgZnVuY3Rpb24gKG1vZGVsLCBkYXRhKSB7XHJcbiAgICBsZXQgdGVzdFNldCA9IGRhdGEudGVzdFNldFxyXG4gICAgbGV0IHJlc3VsdFZlY3RvciA9IG1vZGVsLnByZWRpY3QodGVzdFNldCk7XHJcbiAgICByZXR1cm4gcmVzdWx0VmVjdG9yXHJcbiAgfVxyXG4gIFxyXG4gIEtOZWFyZXN0TmVpZ2hib3JzLm1ldGhvZHMuZ2V0UHJlZGljdFJlc3VsdHNWYWx1ZSA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhLCByZXN1bHRWZWN0b3IpIHtcclxuICAgIGxldCB0cmFpblNldENsYXNzZXNEaWN0ID0gZGF0YS50cmFpblNldENsYXNzZXNEaWN0XHJcbiAgICAvL2NvbnNvbGUubG9nKHRyYWluU2V0Q2xhc3Nlc0RpY3QpXHJcbiAgICByZXR1cm4gcmVzdWx0VmVjdG9yLm1hcChpbmRleCA9PiB7XHJcbiAgICAgIHJldHVybiB0cmFpblNldENsYXNzZXNEaWN0W2luZGV4XVxyXG4gICAgfSlcclxuICB9XHJcbiAgXHJcbiAgS05lYXJlc3ROZWlnaGJvcnMubWV0aG9kcy5ldmFsdWF0aW9uUmVzdWx0cyA9IGFzeW5jIGZ1bmN0aW9uICh0cmFpbiwgcHJlZGljdCkge1xyXG4gICAgXHJcbiAgICB0aGlzLiRwYXJlbnQucmVzZXRNb2RlbEV2YWx1YXRpb24oKVxyXG4gICAgLy8gY29uc29sZS5sb2codHJhaW4pXHJcbiAgICAvLyBjb25zb2xlLmxvZyhwcmVkaWN0KVxyXG4gICAgLy9jb25zb2xlLmxvZyhkYXRhLnRyYWluU2V0Q2xhc3Nlcy5sZW5ndGgsIGdldFRyYWluU2V0UHJlZGljdHMubGVuZ3RoLCBkYXRhLnRlc3RTZXRSb3dJbmRleGVzLmxlbmd0aClcclxuXHJcbiAgICBsZXQgYWNjdXJhY3kgPSBhd2FpdCB0aGlzLiRwYXJlbnQuY2FsY0FjY3VyYWN5KHRyYWluLCBwcmVkaWN0KVxyXG4gICAgLy9jb25zb2xlLmxvZyhhY2N1cmFjeSlcclxuICAgIGxldCBhY2N1cmFjeUluZm8gPSB7XHJcbiAgICAgIG5hbWU6ICdhY2N1cmFjeScsXHJcbiAgICAgIHR5cGU6ICdwZXJjZW50JyxcclxuICAgICAgdmFsdWU6IGFjY3VyYWN5XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vY29uc29sZS5sb2coYWNjdXJhY3lJbmZvKVxyXG4gICAgdGhpcy5sb2NhbENvbmZpZy5tb2RlbEV2YWx1YXRpb25zLnB1c2goYWNjdXJhY3lJbmZvKVxyXG4gIH1cclxufSIsIi8vaW1wb3J0IHtldWNsaWRlYW59IGZyb20gJ21sLWRpc3RhbmNlLWV1Y2xpZGVhbidcbmNvbnN0IGV1Y2xpZGVhbiA9IHJlcXVpcmUoJ21sLWRpc3RhbmNlLWV1Y2xpZGVhbicpLmV1Y2xpZGVhblxuLy9jb25zdCBldWNsaWRlYW4gPSBNTERpc3RhbmNlRXVjbGlkZWFuLmV1Y2xpZGVhblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoS05lYXJlc3ROZWlnaGJvcnMpIHtcbiAgS05lYXJlc3ROZWlnaGJvcnMubWV0aG9kcy5zaG93TW9kZWwgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5tb2RlbClcbiAgICBpZiAoIXRoaXMubW9kZWwpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnQoKVxuICAgICAgLy9jb25zb2xlLmVycm9yKCdubyB0aGlzLm1vZGVsJylcbiAgICAgIC8vcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL2NvbnNvbGUubG9nKHRoaXMuZGF0YVRvU2hvdylcbiAgICBsZXQgdW5rbm93blNldFJvd0luZGV4ID0gdGhpcy5kYXRhVG9TaG93LnRlc3RTZXRSb3dJbmRleGVzXG5cbiAgICBsZXQgbmVpZ2hib3JzID0gW11cbiAgICBsZXQgbmVpZ2hib3JzSUQgPSBbXVxuICAgIGxldCB1bmtub3ducyA9IFtdXG4gICAgbGV0IHVua25vd25zSUQgPSBbXVxuICAgIC8vY29uc29sZS5sb2codW5rbm93blNldFJvd0luZGV4KVxuXG4gICAgdGhpcy5kYXRhVG9TaG93LnRlc3RTZXQuZm9yRWFjaCgoc2V0LCBpKSA9PiB7XG4gICAgICBpZiAodW5rbm93blNldFJvd0luZGV4LmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgIG5laWdoYm9ycy5wdXNoKHNldClcbiAgICAgICAgbmVpZ2hib3JzSUQucHVzaChpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5rbm93bnMucHVzaChzZXQpXG4gICAgICAgIHVua25vd25zSUQucHVzaChpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAodW5rbm93bnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB1bmtub3ducyA9IFtdLmNvbmNhdChuZWlnaGJvcnMpXG4gICAgICB1bmtub3duc0lEID0gW10uY29uY2F0KG5laWdoYm9yc0lEKVxuICAgICAgdW5rbm93blNldFJvd0luZGV4ID0gW10uY29uY2F0KG5laWdoYm9yc0lEKVxuICAgIH1cblxuICAgIC8vY29uc29sZS5sb2cobmVpZ2hib3JzKVxuICAgIC8vIGNvbnNvbGUubG9nKHVua25vd25zKVxuICAgIGlmIChuZWlnaGJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZWlnaGJvcnMgPSB1bmtub3duc1xuICAgICAgbmVpZ2hib3JzSUQgPSB1bmtub3duc0lEXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBsZXQgZGlzdGFuY2VNYXRyaXggPSB1bmtub3ducy5tYXAodW5rbm93bkZlYXR1cmUgPT4ge1xuICAgICAgbGV0IG1heERpc3RhbmNlID0gbnVsbFxuICAgICAgbGV0IGRpc3RhbmNlcyA9IG5laWdoYm9ycy5tYXAobmVpZ2hib3IgPT4ge1xuICAgICAgICBsZXQgZGlzdGFuY2UgPSBldWNsaWRlYW4odW5rbm93bkZlYXR1cmUsIG5laWdoYm9yKVxuICAgICAgICBpZiAobWF4RGlzdGFuY2UgPT09IG51bGwgfHwgZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgIG1heERpc3RhbmNlID0gZGlzdGFuY2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0YW5jZVxuICAgICAgfSlcblxuICAgICAgZGlzdGFuY2VzID0gZGlzdGFuY2VzLm1hcChkID0+IHtcbiAgICAgICAgcmV0dXJuICgobWF4RGlzdGFuY2UgLSBkKSAvIG1heERpc3RhbmNlKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGRpc3RhbmNlc1xuICAgIH0pXG5cbiAgICAvLyBjb25zb2xlLmxvZyhkaXN0YW5jZU1hdHJpeClcbiAgICBpZiAoZGlzdGFuY2VNYXRyaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcignRGlzdGFuY2UgbWF0cml4IGlzIGVtcHR5JylcbiAgICB9XG5cbiAgICBsZXQgY29sb3JNYXRyaXggPSBkaXN0YW5jZU1hdHJpeC5tYXAodW5rbm93biA9PiB7XG4gICAgICByZXR1cm4gdW5rbm93bi5tYXAoZCA9PiB7XG4gICAgICAgIHJldHVybiBoZWF0TWFwQ29sb3Jmb3JWYWx1ZShkKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgLy9jb25zb2xlLmxvZyhjb2xvck1hdHJpeClcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsZXQgdGFibGVIZWFkZXJVbmtub3duQ29sc3BhbiA9IDJcbiAgICBpZiAodGhpcy5tb2RlbCA9PT0gJ3Vuc3VwZXJ2aXNlZCcpIHtcbiAgICAgIHRhYmxlSGVhZGVyVW5rbm93bkNvbHNwYW4gPSAxXG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coe3RhYmxlSGVhZGVyVW5rbm93bkNvbHNwYW4sIGNvbG9yTWF0cml4fSlcblxuICAgIGxldCB0YWJsZUhlYWRlciA9IGA8dGhlYWQ+XG4gIDx0cj5cbiAgICA8dGggcm93c3Bhbj1cIjJcIiBjb2xzcGFuPVwiJHt0YWJsZUhlYWRlclVua25vd25Db2xzcGFufVwiIHZhbGlnbj1cImJvdHRvbVwiPiR7dGhpcy4kdCgnVW5rbm93bnMnKX08L3RoPlxuICAgIDx0aCBjb2xzcGFuPVwiJHtjb2xvck1hdHJpeFswXS5sZW5ndGh9XCI+JHt0aGlzLiR0KCdOZWlnaGJvcnMnKX08L3RoPlxuICA8L3RyPlxuICA8dHI+JHtjb2xvck1hdHJpeFswXS5tYXAoKHZhbHVlLCBpKSA9PiBgPHRoPiR7bmVpZ2hib3JzSURbaV0gKyAxfTwvdGg+YCkuam9pbignJyl9PC90cj5cbjwvdGhlYWQ+YFxuXG4gICAgbGV0IHRyYWluU2V0Q2xhc3Nlc0RpY3QgPSB0aGlzLmRhdGFUb1Nob3cudHJhaW5TZXRDbGFzc2VzRGljdFxuICAgIGxldCB1bmtub3duc1ByZWRpY3Rpb24gPSB0aGlzLnVua25vd25zUHJlZGljdGlvblxuICAgIC8vIGNvbnNvbGUubG9nKHt0cmFpblNldENsYXNzZXNEaWN0LCB1bmtub3duc1ByZWRpY3Rpb259KVxuICAgIGlmICh1bmtub3duc1ByZWRpY3Rpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBsZXQgZGF0YSA9IGF3YWl0IHRoaXMuJHBhcmVudC5nZXRWZWN0b3JEYXRhKClcbiAgICAgIC8vIGxldCBwcmVkaWN0VmVjdG9yID0gYXdhaXQgdGhpcy5nZXRQcmVkaWN0UmVzdWx0c1ZlY3Rvcih0aGlzLm1vZGVsLCBkYXRhKVxuICAgICAgLy8gbGV0IHByZWRpY3RSZXN1bHRzID0gYXdhaXQgdGhpcy5nZXRQcmVkaWN0UmVzdWx0c1ZhbHVlKGRhdGEsIHByZWRpY3RWZWN0b3IpXG4gICAgICAvLyBjb25zb2xlLmxvZyhwcmVkaWN0VmVjdG9yKVxuICAgICAgLy8gY29uc29sZS5sb2coZGF0YSlcbiAgICAgIHVua25vd25zUHJlZGljdGlvbiA9IGF3YWl0IHRoaXMuJHBhcmVudC5nZXRUcmFpblNldFByZWRpY3RzUmVzdWx0KClcbiAgICAgIC8vIHRocm93IEVycm9yKCd0b2RvJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1bmtub3duc1ByZWRpY3Rpb24gPSB1bmtub3duc1ByZWRpY3Rpb24ubWFwKGkgPT4gdHJhaW5TZXRDbGFzc2VzRGljdFtpXSlcbiAgICB9XG5cbiAgICBsZXQgdGFibGVCb2R5ID0gYDx0Ym9keT5cbiR7Y29sb3JNYXRyaXgubWFwKChyb3csIGkpID0+IHtcbiAgICAgIGxldCB0aFByZWRpZWN0aW9uID0gYDx0aD4ke3Vua25vd25zUHJlZGljdGlvbltpXX08L3RoPmBcbiAgICAgIGlmICh0aGlzLm1vZGVsID09PSAndW5zdXBlcnZpc2VkJykge1xuICAgICAgICB0aFByZWRpZWN0aW9uID0gJydcbiAgICAgIH1cbiAgICAgIHJldHVybiBgPHRyPlxuICA8dGg+JHsodW5rbm93blNldFJvd0luZGV4W2ldKSArIDF9PC90aD5cbiAgJHt0aFByZWRpZWN0aW9ufVxuICAke3Jvdy5tYXAoKGNvbG9yLCBqKSA9PiB7XG4gICAgICAgIGxldCBkID0gZGlzdGFuY2VNYXRyaXhbaV1bal1cbiAgICAgICAgbGV0IGRUZXh0ID0gZFxuICAgICAgICBkVGV4dCA9IE1hdGgucm91bmQoZFRleHQgKiAxMDApICsgJyUnXG5cbiAgICAgICAgaWYgKGQgPiAwLjcgfHwgZCA8IDAuMykge1xuICAgICAgICAgIHJldHVybiBgPHRkIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjogJHtjb2xvcn07IGNvbG9yOiB3aGl0ZVwiPiR7ZFRleHR9PC90ZD5gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGA8dGQgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yfVwiPiR7ZFRleHR9PC90ZD5gXG4gICAgICAgIH1cbiAgICAgIH0pLmpvaW4oJycpfVxuPC90cj5gXG4gICAgfSkuam9pbignXFxuJyl9XG48L3Rib2R5PmBcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBjb25zb2xlLmxvZyh0YWJsZUJvZHkpXG5cbiAgICBsZXQgYm9keUhUTUwgPSBgPHRhYmxlIGJvcmRlcj1cIjFcIiBhbGlnbj1cImNlbnRlclwiPlxuICAgICR7dGFibGVIZWFkZXJ9XG4gICAgJHt0YWJsZUJvZHl9XG48L3RhYmxlPmBcbiAgICBib2R5SFRNTCA9IGA8ZGl2IGNsYXNzPVwidHJlZVwiPiR7Ym9keUhUTUx9PC9kaXY+YFxuICAgIC8vY29uc29sZS5lcnJvcignW1RPRE9dJylcbiAgICAvL2NvbnNvbGUubG9nKClcbiAgICBsZXQgdGl0bGUgPSB0aGlzLiR0KCdLTk4nKSArIGAgKGAgKyAobmV3IERhdGUoKSkubW1kZGhobW0oKSArICcpJ1xuXG4gICAgLy8gY29uc29sZS5sb2coJ0tOTk1vZGVsU2hvdycgKyB0aGlzLmNvbmZpZy5tb2RlbEJ1aWxkZWRUaW1lKVxuICAgIGxldCBtb2RlbFdpbmRvdyA9IHRoaXMudXRpbHMuUG9wdXBVdGlscy5vcGVuKHtcbiAgICAgIHdpbmRvd05hbWU6ICdLTk5Nb2RlbFNob3cnICsgdGhpcy5jb25maWcubW9kZWxCdWlsZGVkVGltZSxcbiAgICAgIGNzc1VSTDogdGhpcy5tb2RlbENTU1VSTCxcbiAgICAgIGJvZHlIVE1MLFxuICAgICAgc2l6ZTogJ3JpZ2h0JyxcbiAgICAgIC8vc2l6ZTogJ2xlZnQnLFxuICAgICAgdGl0bGVcbiAgICB9KVxuXG4gICAgbW9kZWxXaW5kb3cuc2Nyb2xsVG9Ub3AoKVxuICAgIG1vZGVsV2luZG93LnNjcm9sbFRvQ2VudGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjcyNjM5MTgvNjY0NTM5OVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhdE1hcENvbG9yZm9yVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgaCA9ICgxLjAgLSB2YWx1ZSkgKiAyNDBcbiAgICByZXR1cm4gXCJoc2woXCIgKyBoICsgXCIsIDEwMCUsIDUwJSlcIjtcbiAgICAvL3JldHVybiBgcmdiYSgyMiwgMTYwLCAxMzMsICR7dmFsdWV9KWBcbiAgICAvLyByZ2IoMjIsIDE2MCwgMTMzKVxuICB9XG59XG4iLCJpbXBvcnQgS05OIGZyb20gJ21sLWtubidcbi8vIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21sLWtublxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoS05lYXJlc3ROZWlnaGJvcnMpIHtcbiAgS05lYXJlc3ROZWlnaGJvcnMubWV0aG9kcy50ZXN0S05OID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhc2V0ID0gW1xuICAgICAgWzAsIDAsIDBdLFxuICAgICAgWzAsIDEsIDFdLFxuICAgICAgWzEsIDEsIDBdLFxuICAgICAgWzIsIDIsIDJdLFxuICAgICAgWzEsIDIsIDJdLFxuICAgICAgWzIsIDEsIDJdXG4gICAgXTtcbiAgICB2YXIgcHJlZGljdGlvbnMgPSBbMCwgMCwgMCwgMSwgMSwgMV07XG4gICAgdmFyIGtubiA9IG5ldyBLTk4oZGF0YXNldCwgcHJlZGljdGlvbnMpO1xuICAgIFxuICAgIHZhciBkYXRhc2V0ID0gW1swLCAwLCAwXSwgWzIsIDIsIDJdXTtcbiBcbiAgICB2YXIgYW5zID0ga25uLnByZWRpY3QoZGF0YXNldCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYW5zKVxuICB9XG59IiwibGV0IEtOZWFyZXN0TmVpZ2hib3JzID0ge1xuICBwcm9wczogWydjb25maWcnLCAnbG9jYWxDb25maWcnLCAndXRpbHMnXSxcbiAgZGF0YSAoKSB7ICAgIFxuICAgIHRoaXMuJGkxOG4ubG9jYWxlID0gdGhpcy5sb2NhbENvbmZpZy5sb2NhbGVcbiAgICByZXR1cm4ge1xuICAgICAgbW9kZWw6IG51bGwsXG4gICAgICBkYXRhVG9TaG93OiBudWxsLFxuICAgICAgdW5rbm93bnNQcmVkaWN0aW9uOiBbXSxcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgJ2xvY2FsQ29uZmlnLmxvY2FsZScoKSB7XG4gICAgICB0aGlzLiRpMThuLmxvY2FsZSA9IHRoaXMubG9jYWxDb25maWcubG9jYWxlO1xuICAgIH0sXG4gICAgJ2xvY2FsQ29uZmlnLktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0snICgpIHtcbiAgICAgIHRoaXMuJHBhcmVudC5jbGVhclByZWRpY3Rpb24oKVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc01vZGVsQnVpbGRlZCAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubW9kZWwgIT09IG51bGwpXG4gICAgfSxcbiAgICBpc01vZGVsVW5zdXBlcnZpc2VkICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tb2RlbCAhPT0gbnVsbCAmJiB0aGlzLm1vZGVsID09PSAndW5zdXBlcnZpc2VkJylcbiAgICB9LFxuICB9LFxuICBtb3VudGVkKCkge1xuLy8gICAgc2V0VGltZW91dCgoKSA9PiB7XG4vLyAgICAgIHRoaXMuc3RhcnQoKVxuLy8gICAgfSwgMTAwMClcblxuICAgIC8vdGhpcy50ZXN0S05OKClcbiAgfSxcbiAgbWV0aG9kczoge31cbn1cblxuaW1wb3J0IEtOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc0J1aWxkIGZyb20gJy4vS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzQnVpbGQuanMnXG5LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNCdWlsZChLTmVhcmVzdE5laWdoYm9ycylcblxuaW1wb3J0IEtOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Nob3cgZnJvbSAnLi9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNTaG93LmpzJ1xuS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzU2hvdyhLTmVhcmVzdE5laWdoYm9ycylcblxuaW1wb3J0IEtOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Rlc3QgZnJvbSAnLi9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNUZXN0LmpzJ1xuS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzVGVzdChLTmVhcmVzdE5laWdoYm9ycylcblxuZXhwb3J0IGRlZmF1bHQgS05lYXJlc3ROZWlnaGJvcnMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTYhLi9LTmVhcmVzdE5laWdoYm9ycy5qcz92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS02IS4vS05lYXJlc3ROZWlnaGJvcnMuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0tOZWFyZXN0TmVpZ2hib3JzLmh0bWw/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWNkZjlmODAmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vS05lYXJlc3ROZWlnaGJvcnMuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0tOZWFyZXN0TmVpZ2hib3JzLmpzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01Y2RmOWY4MCZwcm9kJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNWNkZjlmODBcIixcbiAgbnVsbFxuICBcbilcblxuLyogY3VzdG9tIGJsb2NrcyAqL1xuaW1wb3J0IGJsb2NrMCBmcm9tIFwiLi9LTmVhcmVzdE5laWdoYm9ycy55YW1sP3Z1ZSZ0eXBlPWN1c3RvbSZpbmRleD0wJmJsb2NrVHlwZT1pMThuJmlzc3VlclBhdGg9JTJGYXBwJTJGc3JjJTJGY29tcG9uZW50cyUyRkNvbmZpZ3VyYXRpb25QYW5lbCUyRktOZWFyZXN0TmVpZ2hib3JzJTJGS05lYXJlc3ROZWlnaGJvcnMudnVlJmxhbmc9eWFtbFwiXG5pZiAodHlwZW9mIGJsb2NrMCA9PT0gJ2Z1bmN0aW9uJykgYmxvY2swKGNvbXBvbmVudClcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQWdCQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQWNBO0FBQUE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNIQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQzdDQTs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///575\n')}}]);