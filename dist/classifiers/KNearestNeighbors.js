(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{204:function(module,exports){eval('module.exports = function (Component) {\n  Component.options.__i18n = Component.options.__i18n || []\n  Component.options.__i18n.push(\'{"en":{"TEST_MESSAGE":"Test Message"},"zh-TW":{"TEST_MESSAGE":"測試訊息"}}\')\n  delete Component.options._Ctor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLnlhbWw/NWNjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuID0gQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuIHx8IFtdXG4gIENvbXBvbmVudC5vcHRpb25zLl9faTE4bi5wdXNoKCd7XCJlblwiOntcIlRFU1RfTUVTU0FHRVwiOlwiVGVzdCBNZXNzYWdlXCJ9LFwiemgtVFdcIjp7XCJURVNUX01FU1NBR0VcIjpcIua4rOippuioiuaBr1wifX0nKVxuICBkZWxldGUgQ29tcG9uZW50Lm9wdGlvbnMuX0N0b3Jcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///204\n')},377:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredEuclidean", function() { return squaredEuclidean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "euclidean", function() { return euclidean; });\nfunction squaredEuclidean(p, q) {\r\n    let d = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        d += (p[i] - q[i]) * (p[i] - q[i]);\r\n    }\r\n    return d;\r\n}\r\nfunction euclidean(p, q) {\r\n    return Math.sqrt(squaredEuclidean(p, q));\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLWRpc3RhbmNlLWV1Y2xpZGVhbi9saWItZXM2L2V1Y2xpZGVhbi5qcz81OWU3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRXVjbGlkZWFuKHAsIHEpIHtcclxuICAgIGxldCBkID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGQgKz0gKHBbaV0gLSBxW2ldKSAqIChwW2ldIC0gcVtpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXVjbGlkZWFuKHAsIHEpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlZEV1Y2xpZGVhbihwLCBxKSk7XHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///377\n')},378:function(module,exports,__webpack_require__){eval("var api = __webpack_require__(5);\n            var content = __webpack_require__(485);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/ODJiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMyEuL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xMjk1MjQ1YyZsYW5nPWxlc3Mmc2NvcGVkPXRydWUmXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///378\n")},484:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_1295245c_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(378);\n/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_1295245c_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_1295245c_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/OWUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMyEuL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xMjk1MjQ1YyZsYW5nPWxlc3Mmc2NvcGVkPXRydWUmXCIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///484\n")},485:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(4);\nexports = ___CSS_LOADER_API_IMPORT___(true);\n// Module\nexports.push([module.i, "", "",{"version":3,"sources":[],"names":[],"mappings":"","file":"KNearestNeighbors.less"}]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/YjkwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJmaWxlXCI6XCJLTmVhcmVzdE5laWdoYm9ycy5sZXNzXCJ9XSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///485\n')},486:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_E_3A_5Cpudding_5CCode_Porjects_5Chtml_api_5CHTML_Simple_Classifier_5Csrc_5Ccomponents_5CConfigurationPanel_5CKNearestNeighbors_5CKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(204);\n/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_E_3A_5Cpudding_5CCode_Porjects_5Chtml_api_5CHTML_Simple_Classifier_5Csrc_5Ccomponents_5CConfigurationPanel_5CKNearestNeighbors_5CKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_E_3A_5Cpudding_5CCode_Porjects_5Chtml_api_5CHTML_Simple_Classifier_5Csrc_5Ccomponents_5CConfigurationPanel_5CKNearestNeighbors_5CKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__);\n /* harmony default export */ __webpack_exports__["default"] = (_node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_E_3A_5Cpudding_5CCode_Porjects_5Chtml_api_5CHTML_Simple_Classifier_5Csrc_5Ccomponents_5CConfigurationPanel_5CKNearestNeighbors_5CKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLnlhbWw/NGFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2F6dXBvbi92dWUtaTE4bi1sb2FkZXIvbGliL2luZGV4LmpzIS4vS05lYXJlc3ROZWlnaGJvcnMueWFtbD92dWUmdHlwZT1jdXN0b20maW5kZXg9MCZibG9ja1R5cGU9aTE4biZpc3N1ZXJQYXRoPUUlM0ElNUNwdWRkaW5nJTVDQ29kZS1Qb3JqZWN0cyU1Q2h0bWwtYXBpJTVDSFRNTC1TaW1wbGUtQ2xhc3NpZmllciU1Q3NyYyU1Q2NvbXBvbmVudHMlNUNDb25maWd1cmF0aW9uUGFuZWwlNUNLTmVhcmVzdE5laWdoYm9ycyU1Q0tOZWFyZXN0TmVpZ2hib3JzLnZ1ZSZsYW5nPXlhbWxcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGthenVwb24vdnVlLWkxOG4tbG9hZGVyL2xpYi9pbmRleC5qcyEuL0tOZWFyZXN0TmVpZ2hib3JzLnlhbWw/dnVlJnR5cGU9Y3VzdG9tJmluZGV4PTAmYmxvY2tUeXBlPWkxOG4maXNzdWVyUGF0aD1FJTNBJTVDcHVkZGluZyU1Q0NvZGUtUG9yamVjdHMlNUNodG1sLWFwaSU1Q0hUTUwtU2ltcGxlLUNsYXNzaWZpZXIlNUNzcmMlNUNjb21wb25lbnRzJTVDQ29uZmlndXJhdGlvblBhbmVsJTVDS05lYXJlc3ROZWlnaGJvcnMlNUNLTmVhcmVzdE5laWdoYm9ycy52dWUmbGFuZz15YW1sXCIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///486\n')},513:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.html?vue&type=template&id=1295245c&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c("div", { staticClass: "DecisionTree" }, [\n    _c("div", { staticClass: "field" }, [\n      _c("label", { attrs: { for: "KNearestNeighborsOptionsK" } }, [\n        _vm._v(_vm._s(_vm.$t("K-nearest neighbor")))\n      ]),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.KNearestNeighborsOptionsK,\n            expression: "localConfig.KNearestNeighborsOptionsK"\n          }\n        ],\n        attrs: { type: "number", min: "2", id: "KNearestNeighborsOptionsK" },\n        domProps: { value: _vm.localConfig.KNearestNeighborsOptionsK },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig,\n              "KNearestNeighborsOptionsK",\n              $event.target.value\n            )\n          }\n        }\n      })\n    ]),\n    _vm._v(" "),\n    !_vm.isModelBuilded\n      ? _c("div", { staticClass: "ui field" }, [\n          _c(\n            "button",\n            {\n              staticClass: "ui primary fluid button",\n              attrs: { type: "button" },\n              on: { click: _vm.start }\n            },\n            [\n              [\n                _vm._v(\n                  "\\r\\n        " +\n                    _vm._s(_vm.$t("Build Model and Predict")) +\n                    "\\r\\n      "\n                )\n              ]\n            ],\n            2\n          )\n        ])\n      : _vm._e(),\n    _vm._v(" "),\n    _vm.isModelBuilded && !_vm.isModelUnsupervised\n      ? _c("div", { staticClass: "ui field" }, [\n          _c(\n            "button",\n            {\n              staticClass: "ui primary fluid button",\n              class: { disabled: !_vm.$parent.isNeedPredict },\n              attrs: { type: "button" },\n              on: { click: _vm.start }\n            },\n            [\n              [\n                _vm._v(\n                  "\\r\\n        " + _vm._s(_vm.$t("Predict")) + "\\r\\n      "\n                )\n              ]\n            ],\n            2\n          )\n        ])\n      : _vm._e(),\n    _vm._v(" "),\n    _vm.isModelBuilded\n      ? _c("div", { staticClass: "ui field" }, [\n          _c(\n            "button",\n            {\n              staticClass: "ui primary fluid button",\n              attrs: { type: "button" },\n              on: { click: _vm.showModel }\n            },\n            [_vm._v("\\r\\n      " + _vm._s(_vm.$t("Show Model")) + "\\r\\n    ")]\n          )\n        ])\n      : _vm._e()\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.html?vue&type=template&id=1295245c&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(1);\nvar asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__(0);\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n\n// EXTERNAL MODULE: ./node_modules/ml-distance-euclidean/lib-es6/euclidean.js\nvar euclidean = __webpack_require__(377);\n\n// CONCATENATED MODULE: ./node_modules/ml-knn/src/KDTree.js\n/*\n * Original code from:\n *\n * k-d Tree JavaScript - V 1.01\n *\n * https://github.com/ubilabs/kd-tree-javascript\n *\n * @author Mircea Pricop <pricop@ubilabs.net>, 2012\n * @author Martin Kleppe <kleppe@ubilabs.net>, 2012\n * @author Ubilabs http://ubilabs.net, 2012\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */\n\nfunction Node(obj, dimension, parent) {\n  this.obj = obj;\n  this.left = null;\n  this.right = null;\n  this.parent = parent;\n  this.dimension = dimension;\n}\n\nclass KDTree {\n  constructor(points, metric) {\n    // If points is not an array, assume we\'re loading a pre-built tree\n    if (!Array.isArray(points)) {\n      this.dimensions = points.dimensions;\n      this.root = points;\n      restoreParent(this.root);\n    } else {\n      this.dimensions = new Array(points[0].length);\n      for (var i = 0; i < this.dimensions.length; i++) {\n        this.dimensions[i] = i;\n      }\n      this.root = buildTree(points, 0, null, this.dimensions);\n    }\n    this.metric = metric;\n  }\n\n  // Convert to a JSON serializable structure; this just requires removing\n  // the `parent` property\n  toJSON() {\n    const result = toJSONImpl(this.root, true);\n    result.dimensions = this.dimensions;\n    return result;\n  }\n\n  nearest(point, maxNodes, maxDistance) {\n    const metric = this.metric;\n    const dimensions = this.dimensions;\n    var i;\n\n    const bestNodes = new BinaryHeap(function (e) {\n      return -e[1];\n    });\n\n    function nearestSearch(node) {\n      const dimension = dimensions[node.dimension];\n      const ownDistance = metric(point, node.obj);\n      const linearPoint = {};\n      var bestChild, linearDistance, otherChild, i;\n\n      function saveNode(node, distance) {\n        bestNodes.push([node, distance]);\n        if (bestNodes.size() > maxNodes) {\n          bestNodes.pop();\n        }\n      }\n\n      for (i = 0; i < dimensions.length; i += 1) {\n        if (i === node.dimension) {\n          linearPoint[dimensions[i]] = point[dimensions[i]];\n        } else {\n          linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n        }\n      }\n\n      linearDistance = metric(linearPoint, node.obj);\n\n      if (node.right === null && node.left === null) {\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n          saveNode(node, ownDistance);\n        }\n        return;\n      }\n\n      if (node.right === null) {\n        bestChild = node.left;\n      } else if (node.left === null) {\n        bestChild = node.right;\n      } else {\n        if (point[dimension] < node.obj[dimension]) {\n          bestChild = node.left;\n        } else {\n          bestChild = node.right;\n        }\n      }\n\n      nearestSearch(bestChild);\n\n      if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n        saveNode(node, ownDistance);\n      }\n\n      if (\n        bestNodes.size() < maxNodes ||\n        Math.abs(linearDistance) < bestNodes.peek()[1]\n      ) {\n        if (bestChild === node.left) {\n          otherChild = node.right;\n        } else {\n          otherChild = node.left;\n        }\n        if (otherChild !== null) {\n          nearestSearch(otherChild);\n        }\n      }\n    }\n\n    if (maxDistance) {\n      for (i = 0; i < maxNodes; i += 1) {\n        bestNodes.push([null, maxDistance]);\n      }\n    }\n\n    if (this.root) {\n      nearestSearch(this.root);\n    }\n\n    const result = [];\n    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\n      if (bestNodes.content[i][0]) {\n        result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\n      }\n    }\n    return result;\n  }\n}\n\nfunction toJSONImpl(src) {\n  const dest = new Node(src.obj, src.dimension, null);\n  if (src.left) dest.left = toJSONImpl(src.left);\n  if (src.right) dest.right = toJSONImpl(src.right);\n  return dest;\n}\n\nfunction buildTree(points, depth, parent, dimensions) {\n  const dim = depth % dimensions.length;\n\n  if (points.length === 0) {\n    return null;\n  }\n  if (points.length === 1) {\n    return new Node(points[0], dim, parent);\n  }\n\n  points.sort((a, b) => a[dimensions[dim]] - b[dimensions[dim]]);\n\n  const median = Math.floor(points.length / 2);\n  const node = new Node(points[median], dim, parent);\n  node.left = buildTree(points.slice(0, median), depth + 1, node, dimensions);\n  node.right = buildTree(points.slice(median + 1), depth + 1, node, dimensions);\n\n  return node;\n}\n\nfunction restoreParent(root) {\n  if (root.left) {\n    root.left.parent = root;\n    restoreParent(root.left);\n  }\n\n  if (root.right) {\n    root.right.parent = root;\n    restoreParent(root.right);\n  }\n}\n\n// Binary heap implementation from:\n// http://eloquentjavascript.net/appendix2.html\nclass BinaryHeap {\n  constructor(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  }\n\n  peek() {\n    return this.content[0];\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n];\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element\'s index, and fetch it.\n      const parentN = Math.floor((n + 1) / 2) - 1;\n      const parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update \'n\' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to move it further.\n        break;\n      }\n    }\n  }\n\n  sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        var child1Score = this.scoreFunction(child1);\n        // If the score is less than our element\'s, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } else {\n        // Otherwise, we are done.\n        break;\n      }\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/ml-knn/src/index.js\n\n\n\n\nclass src_KNN {\n  /**\n   * @param {Array} dataset\n   * @param {Array} labels\n   * @param {object} options\n   * @param {number} [options.k=numberOfClasses + 1] - Number of neighbors to classify.\n   * @param {function} [options.distance=euclideanDistance] - Distance function that takes two parameters.\n   */\n  constructor(dataset, labels, options = {}) {\n    if (dataset === true) {\n      const model = labels;\n      this.kdTree = new KDTree(model.kdTree, options);\n      this.k = model.k;\n      this.classes = new Set(model.classes);\n      this.isEuclidean = model.isEuclidean;\n      return;\n    }\n\n    const classes = new Set(labels);\n\n    const { distance = euclidean["euclidean"], k = classes.size + 1 } = options;\n\n    const points = new Array(dataset.length);\n    for (var i = 0; i < points.length; ++i) {\n      points[i] = dataset[i].slice();\n    }\n\n    for (i = 0; i < labels.length; ++i) {\n      points[i].push(labels[i]);\n    }\n\n    this.kdTree = new KDTree(points, distance);\n    this.k = k;\n    this.classes = classes;\n    this.isEuclidean = distance === euclidean["euclidean"];\n  }\n\n  /**\n   * Create a new KNN instance with the given model.\n   * @param {object} model\n   * @param {function} distance=euclideanDistance - distance function must be provided if the model wasn\'t trained with euclidean distance.\n   * @return {KNN}\n   */\n  static load(model, distance = euclidean["euclidean"]) {\n    if (model.name !== \'KNN\') {\n      throw new Error(`invalid model: ${model.name}`);\n    }\n    if (!model.isEuclidean && distance === euclidean["euclidean"]) {\n      throw new Error(\n        \'a custom distance function was used to create the model. Please provide it again\'\n      );\n    }\n    if (model.isEuclidean && distance !== euclidean["euclidean"]) {\n      throw new Error(\n        \'the model was created with the default distance function. Do not load it with another one\'\n      );\n    }\n    return new src_KNN(true, model, distance);\n  }\n\n  /**\n   * Return a JSON containing the kd-tree model.\n   * @return {object} JSON KNN model.\n   */\n  toJSON() {\n    return {\n      name: \'KNN\',\n      kdTree: this.kdTree,\n      k: this.k,\n      classes: Array.from(this.classes),\n      isEuclidean: this.isEuclidean\n    };\n  }\n\n  /**\n   * Predicts the output given the matrix to predict.\n   * @param {Array} dataset\n   * @return {Array} predictions\n   */\n  predict(dataset) {\n    if (Array.isArray(dataset)) {\n      if (typeof dataset[0] === \'number\') {\n        return getSinglePrediction(this, dataset);\n      } else if (\n        Array.isArray(dataset[0]) &&\n        typeof dataset[0][0] === \'number\'\n      ) {\n        const predictions = new Array(dataset.length);\n        for (var i = 0; i < dataset.length; i++) {\n          predictions[i] = getSinglePrediction(this, dataset[i]);\n        }\n        return predictions;\n      }\n    }\n    throw new TypeError(\'dataset to predict must be an array or a matrix\');\n  }\n}\n\nfunction getSinglePrediction(knn, currentCase) {\n  var nearestPoints = knn.kdTree.nearest(currentCase, knn.k);\n  var pointsPerClass = {};\n  var predictedClass = -1;\n  var maxPoints = -1;\n  var lastElement = nearestPoints[0][0].length - 1;\n\n  for (var element of knn.classes) {\n    pointsPerClass[element] = 0;\n  }\n\n  for (var i = 0; i < nearestPoints.length; ++i) {\n    var currentClass = nearestPoints[i][0][lastElement];\n    var currentPoints = ++pointsPerClass[currentClass];\n    if (currentPoints > maxPoints) {\n      predictedClass = currentClass;\n      maxPoints = currentPoints;\n    }\n  }\n\n  return predictedClass;\n}\n\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighborsMethodsBuild.js\n\n\n\n/* harmony default export */ var KNearestNeighborsMethodsBuild = (function (KNearestNeighbors) {\n  KNearestNeighbors.methods.startPredict = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return this.start();\n\n          case 2:\n            return _context.abrupt("return", _context.sent);\n\n          case 3:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  KNearestNeighbors.methods.start = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n    var _this = this;\n\n    var data, predictVector, predictResults, testSetRowIndexes, predictVectorToEvalute;\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            //this.localConfig.modelJSON = null\n            this.config.loadingProgress = 0;\n            console.log(\'start\', 1);\n            this.localConfig.modelJSON = null;\n            this.localConfig.modelEvaluations = [];\n            _context2.next = 6;\n            return this.$parent.getVectorData();\n\n          case 6:\n            data = _context2.sent;\n            this.dataToShow = data;\n\n            if (data.trainSetClasses.length === 0) {\n              console.error(\'No trainSetClasses\'); //throw Error(\'No trainSetClasses\')\n            }\n\n            console.log(data); //return false\n\n            this.config.loadingProgress = 0.25;\n            console.log(\'start\', 2); //console.log(data.trainSet[0])\n\n            console.log(\'start\', 3);\n\n            if (!(data.trainSetClasses.length > 0)) {\n              _context2.next = 36;\n              break;\n            }\n\n            if (!this.localConfig.modelJSON) {\n              this.model = this.buildModel(data);\n              this.localConfig.modelJSON = this.model;\n            } else {\n              this.model = src_KNN.load(this.localConfig.modelJSON);\n            } //console.log(this.model.toJSON())\n            //console.log(this.model)\n\n\n            console.log(\'start\', 5);\n            this.config.loadingProgress = 0.5;\n            console.log(\'start\', 9); //console.log(data.testSet)\n\n            _context2.next = 20;\n            return this.getPredictResultsVector(this.model, data);\n\n          case 20:\n            predictVector = _context2.sent;\n            _context2.next = 23;\n            return this.getPredictResultsValue(data, predictVector);\n\n          case 23:\n            predictResults = _context2.sent;\n            console.log(predictVector);\n\n            if (!(predictResults[0] === \'undefined\')) {\n              _context2.next = 29;\n              break;\n            }\n\n            this.config.loadingProgress = 1;\n            console.error(\'predict is undefined\');\n            return _context2.abrupt("return", false);\n\n          case 29:\n            console.log(\'start\', 10);\n            this.config.loadingProgress = 0.75;\n\n            if (this.$parent.hasModelEvaluated === false) {\n              testSetRowIndexes = data.testSetRowIndexes;\n              this.unknownsPrediction = [];\n              predictVectorToEvalute = predictVector.filter(function (value, i) {\n                var notMatch = testSetRowIndexes.indexOf(i) === -1;\n\n                if (notMatch === false) {\n                  _this.unknownsPrediction.push(value);\n                }\n\n                return notMatch;\n              });\n              this.evaluationResults(data.trainSetClasses, predictVectorToEvalute);\n            } //console.log(predictResults)\n\n\n            this.$parent.setPredictResults(predictResults);\n            this.config.loadingProgress = 0.9;\n            _context2.next = 37;\n            break;\n\n          case 36:\n            this.model = \'unsupervised\';\n\n          case 37:\n            if (this.$parent.isModelWindowOpened) {\n              this.showModel();\n            }\n\n            this.config.loadingProgress = 1;\n            this.config.modelBuildedTime = new Date().getTime();\n\n          case 40:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n\n  KNearestNeighbors.methods.buildModel = function (data) {\n    var testSetRowIndexes = data.testSetRowIndexes;\n    var dataset = data.testSet.filter(function (row, i) {\n      return testSetRowIndexes.indexOf(i) === -1;\n    });\n    console.log(dataset);\n    var predictions = data.trainSetClasses;\n\n    if (dataset.length === 0) {\n      dataset = data.testSet;\n      predictions = dataset.map(function (item) {\n        return \'unknown\';\n      });\n    }\n\n    if (dataset.length !== predictions.length) {\n      console.error(\'length is not match\');\n    }\n\n    return new src_KNN(dataset, predictions, {\n      k: this.localConfig.KNearestNeighborsOptionsK\n    });\n  };\n\n  KNearestNeighbors.methods.getPredictResultsVector = /*#__PURE__*/function () {\n    var _ref3 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3(model, data) {\n      var testSet, resultVector;\n      return regenerator_default.a.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              testSet = data.testSet;\n              resultVector = model.predict(testSet);\n              return _context3.abrupt("return", resultVector);\n\n            case 3:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x, _x2) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  KNearestNeighbors.methods.getPredictResultsValue = /*#__PURE__*/function () {\n    var _ref4 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee4(data, resultVector) {\n      var trainSetClassesDict;\n      return regenerator_default.a.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              trainSetClassesDict = data.trainSetClassesDict; //console.log(trainSetClassesDict)\n\n              return _context4.abrupt("return", resultVector.map(function (index) {\n                return trainSetClassesDict[index];\n              }));\n\n            case 2:\n            case "end":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x3, _x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  KNearestNeighbors.methods.evaluationResults = /*#__PURE__*/function () {\n    var _ref5 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee5(train, predict) {\n      var accuracy, accuracyInfo;\n      return regenerator_default.a.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              this.$parent.resetModelEvaluation();\n              console.log(train);\n              console.log(predict); //console.log(data.trainSetClasses.length, getTrainSetPredicts.length, data.testSetRowIndexes.length)\n\n              _context5.next = 5;\n              return this.$parent.calcAccuracy(train, predict);\n\n            case 5:\n              accuracy = _context5.sent;\n              //console.log(accuracy)\n              accuracyInfo = {\n                name: \'accuracy\',\n                type: \'percent\',\n                value: accuracy\n              }; //console.log(accuracyInfo)\n\n              this.localConfig.modelEvaluations.push(accuracyInfo);\n\n            case 8:\n            case "end":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this);\n    }));\n\n    return function (_x5, _x6) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n});\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighborsMethodsShow.js\n\n\n\n//import {euclidean} from \'ml-distance-euclidean\'\nvar KNearestNeighborsMethodsShow_euclidean = __webpack_require__(377).euclidean; //const euclidean = MLDistanceEuclidean.euclidean\n\n\n/* harmony default export */ var KNearestNeighborsMethodsShow = (function (KNearestNeighbors) {\n  KNearestNeighbors.methods.showModel = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    var _this = this;\n\n    var unknownSetRowIndex, neighbors, neighborsID, unknowns, unknownsID, distanceMatrix, colorMatrix, tableHeaderUnknownColspan, tableHeader, trainSetClassesDict, tableBody, bodyHTML, title, modelWindow;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (this.model) {\n              _context.next = 3;\n              break;\n            }\n\n            _context.next = 3;\n            return this.start();\n\n          case 3:\n            // --------------------------\n            //console.log(this.dataToShow)\n            unknownSetRowIndex = this.dataToShow.testSetRowIndexes;\n            neighbors = [];\n            neighborsID = [];\n            unknowns = [];\n            unknownsID = []; //console.log(unknownSetRowIndex)\n\n            this.dataToShow.testSet.forEach(function (set, i) {\n              if (unknownSetRowIndex.indexOf(i) === -1) {\n                neighbors.push(set);\n                neighborsID.push(i);\n              } else {\n                unknowns.push(set);\n                unknownsID.push(i);\n              }\n            }); //console.log(neighbors)\n            //console.log(unknowns)\n\n            if (neighbors.length === 0) {\n              neighbors = unknowns;\n              neighborsID = unknownsID;\n            } // --------------------------\n\n\n            distanceMatrix = unknowns.map(function (unknownFeature) {\n              var maxDistance = null;\n              var distances = neighbors.map(function (neighbor) {\n                var distance = KNearestNeighborsMethodsShow_euclidean(unknownFeature, neighbor);\n\n                if (maxDistance === null || distance > maxDistance) {\n                  maxDistance = distance;\n                }\n\n                return distance;\n              });\n              distances = distances.map(function (d) {\n                return (maxDistance - d) / maxDistance;\n              });\n              return distances;\n            }); //console.log(distanceMatrix)\n\n            colorMatrix = distanceMatrix.map(function (unknown) {\n              return unknown.map(function (d) {\n                return heatMapColorforValue(d);\n              });\n            }); //console.log(colorMatrix)\n            // --------------------------\n\n            tableHeaderUnknownColspan = 2;\n\n            if (this.model === \'unsupervised\') {\n              tableHeaderUnknownColspan = 1;\n            }\n\n            tableHeader = "<thead>\\n  <tr>\\n    <th rowspan=\\"2\\" colspan=\\"".concat(tableHeaderUnknownColspan, "\\" valign=\\"bottom\\">").concat(this.$t(\'Unknowns\'), "</th>\\n    <th colspan=\\"").concat(colorMatrix[0].length, "\\">").concat(this.$t(\'Neighbors\'), "</th>\\n  </tr>\\n  <tr>").concat(colorMatrix[0].map(function (value, i) {\n              return "<th>".concat(neighborsID[i] + 1, "</th>");\n            }).join(\'\'), "</tr>\\n</thead>");\n            trainSetClassesDict = this.dataToShow.trainSetClassesDict;\n            tableBody = "<tbody>\\n".concat(colorMatrix.map(function (row, i) {\n              var thPrediection = "<th>".concat(trainSetClassesDict[_this.unknownsPrediction[i]], "</th>");\n\n              if (_this.model === \'unsupervised\') {\n                thPrediection = \'\';\n              }\n\n              return "<tr>\\n  <th>".concat(unknownSetRowIndex[i] + 1, "</th>\\n  ").concat(thPrediection, "\\n  ").concat(row.map(function (color, j) {\n                var d = distanceMatrix[i][j];\n                var dText = d;\n                dText = Math.round(dText * 100) + \'%\';\n\n                if (d > 0.7 || d < 0.3) {\n                  return "<td style=\\"text-align:center;background-color: ".concat(color, "; color: white\\">").concat(dText, "</td>");\n                } else {\n                  return "<td style=\\"text-align:center;background-color: ".concat(color, "\\">").concat(dText, "</td>");\n                }\n              }).join(\'\'), "\\n</tr>");\n            }).join(\'\\n\'), "\\n</tbody>"); // --------------------------\n\n            bodyHTML = "<table border=\\"1\\" align=\\"center\\">\\n    ".concat(tableHeader, "\\n    ").concat(tableBody, "\\n</table>");\n            bodyHTML = "<div class=\\"tree\\">".concat(bodyHTML, "</div>"); //console.error(\'[TODO]\')\n            //console.log()\n\n            title = this.$t(\'KNN\') + " (" + new Date().mmddhhmm() + \')\'; //console.log(\'KNNModelShow\' + this.config.modelBuildedTime)\n\n            modelWindow = this.utils.PopupUtils.open({\n              windowName: \'KNNModelShow\' + this.config.modelBuildedTime,\n              cssURL: this.modelCSSURL,\n              bodyHTML: bodyHTML,\n              size: \'right\',\n              //size: \'left\',\n              title: title\n            });\n            modelWindow.scrollToTop();\n            modelWindow.scrollToCenter();\n\n          case 23:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  /**\r\n   * https://stackoverflow.com/a/27263918/6645399\r\n   */\n\n  function heatMapColorforValue(value) {\n    var h = (1.0 - value) * 240;\n    return "hsl(" + h + ", 100%, 50%)"; //return `rgba(22, 160, 133, ${value})`\n    // rgb(22, 160, 133)\n  }\n});\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighborsMethodsTest.js\n\n\n // https://www.npmjs.com/package/ml-knn\n\n/* harmony default export */ var KNearestNeighborsMethodsTest = (function (KNearestNeighbors) {\n  KNearestNeighbors.methods.testKNN = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    var dataset, predictions, knn, ans;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            dataset = [[0, 0, 0], [0, 1, 1], [1, 1, 0], [2, 2, 2], [1, 2, 2], [2, 1, 2]];\n            predictions = [0, 0, 0, 1, 1, 1];\n            knn = new src_KNN(dataset, predictions);\n            dataset = [[0, 0, 0], [2, 2, 2]];\n            ans = knn.predict(dataset);\n            console.log(ans);\n\n          case 6:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n});\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--6!./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.js?vue&type=script&lang=js&\nvar KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors = {\n  props: [\'config\', \'localConfig\', \'utils\'],\n  data: function data() {\n    this.$i18n.locale = this.localConfig.locale;\n    return {\n      model: null,\n      dataToShow: null,\n      unknownsPrediction: []\n    };\n  },\n  watch: {\n    \'localConfig.locale\': function localConfigLocale() {\n      this.$i18n.locale = this.localConfig.locale;\n    },\n    \'localConfig.KNearestNeighborsOptionsK\': function localConfigKNearestNeighborsOptionsK() {\n      this.$parent.clearPrediction();\n    }\n  },\n  computed: {\n    isModelBuilded: function isModelBuilded() {\n      return this.model !== null;\n    },\n    isModelUnsupervised: function isModelUnsupervised() {\n      return this.model !== null && this.model === \'unsupervised\';\n    }\n  },\n  mounted: function mounted() {//    setTimeout(() => {\n    //      this.start()\n    //    }, 1000)\n    //this.testKNN()\n  },\n  methods: {}\n};\n\nKNearestNeighborsMethodsBuild(KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n\nKNearestNeighborsMethodsShow(KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n\nKNearestNeighborsMethodsTest(KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n/* harmony default export */ var KNearestNeighborsvue_type_script_lang_js_ = (KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.js?vue&type=script&lang=js&\n /* harmony default export */ var KNearestNeighbors_KNearestNeighborsvue_type_script_lang_js_ = (KNearestNeighborsvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.less?vue&type=style&index=0&id=1295245c&lang=less&scoped=true&\nvar KNearestNeighborsvue_type_style_index_0_id_1295245c_lang_less_scoped_true_ = __webpack_require__(484);\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=E%3A%5Cpudding%5CCode-Porjects%5Chtml-api%5CHTML-Simple-Classifier%5Csrc%5Ccomponents%5CConfigurationPanel%5CKNearestNeighbors%5CKNearestNeighbors.vue&lang=yaml\nvar KNearestNeighborsvue_type_custom_index_0_blockType_i18n_issuerPath_E_3A_5Cpudding_5CCode_Porjects_5Chtml_api_5CHTML_Simple_Classifier_5Csrc_5Ccomponents_5CConfigurationPanel_5CKNearestNeighbors_5CKNearestNeighbors_vue_lang_yaml = __webpack_require__(486);\n\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  KNearestNeighbors_KNearestNeighborsvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "1295245c",\n  null\n  \n)\n\n/* custom blocks */\n\nif (typeof KNearestNeighborsvue_type_custom_index_0_blockType_i18n_issuerPath_E_3A_5Cpudding_5CCode_Porjects_5Chtml_api_5CHTML_Simple_Classifier_5Csrc_5Ccomponents_5CConfigurationPanel_5CKNearestNeighbors_5CKNearestNeighbors_vue_lang_yaml["default"] === \'function\') Object(KNearestNeighborsvue_type_custom_index_0_blockType_i18n_issuerPath_E_3A_5Cpudding_5CCode_Porjects_5Chtml_api_5CHTML_Simple_Classifier_5Csrc_5Ccomponents_5CConfigurationPanel_5CKNearestNeighbors_5CKNearestNeighbors_vue_lang_yaml["default"])(component)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.vue"\n/* harmony default export */ var KNearestNeighbors_KNearestNeighbors = __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmh0bWw/NzQ4OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwta25uL3NyYy9LRFRyZWUuanM/OWQwYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwta25uL3NyYy9pbmRleC5qcz8yNjEyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NvbmZpZ3VyYXRpb25QYW5lbC9LTmVhcmVzdE5laWdoYm9ycy9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNCdWlsZC5qcz8zMWM0Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NvbmZpZ3VyYXRpb25QYW5lbC9LTmVhcmVzdE5laWdoYm9ycy9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNTaG93LmpzPzNkYjciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Rlc3QuanM/NTU0NiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMuanM/ZmFiMiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMuanM/ZjAxNiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMudnVlP2RkODMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIkRlY2lzaW9uVHJlZVwiIH0sIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgX2MoXCJsYWJlbFwiLCB7IGF0dHJzOiB7IGZvcjogXCJLTmVhcmVzdE5laWdoYm9yc09wdGlvbnNLXCIgfSB9LCBbXG4gICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLiR0KFwiSy1uZWFyZXN0IG5laWdoYm9yXCIpKSlcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLmxvY2FsQ29uZmlnLktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0ssXG4gICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0tcIlxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJudW1iZXJcIiwgbWluOiBcIjJcIiwgaWQ6IFwiS05lYXJlc3ROZWlnaGJvcnNPcHRpb25zS1wiIH0sXG4gICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubG9jYWxDb25maWcuS05lYXJlc3ROZWlnaGJvcnNPcHRpb25zSyB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF92bS4kc2V0KFxuICAgICAgICAgICAgICBfdm0ubG9jYWxDb25maWcsXG4gICAgICAgICAgICAgIFwiS05lYXJlc3ROZWlnaGJvcnNPcHRpb25zS1wiLFxuICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF0pLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgIV92bS5pc01vZGVsQnVpbGRlZFxuICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInVpIGZpZWxkXCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidWkgcHJpbWFyeSBmbHVpZCBidXR0b25cIixcbiAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnN0YXJ0IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIlxcclxcbiAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLiR0KFwiQnVpbGQgTW9kZWwgYW5kIFByZWRpY3RcIikpICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG4gICAgICBcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDJcbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICA6IF92bS5fZSgpLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX3ZtLmlzTW9kZWxCdWlsZGVkICYmICFfdm0uaXNNb2RlbFVuc3VwZXJ2aXNlZFxuICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInVpIGZpZWxkXCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidWkgcHJpbWFyeSBmbHVpZCBidXR0b25cIixcbiAgICAgICAgICAgICAgY2xhc3M6IHsgZGlzYWJsZWQ6ICFfdm0uJHBhcmVudC5pc05lZWRQcmVkaWN0IH0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5zdGFydCB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgXCJcXHJcXG4gICAgICAgIFwiICsgX3ZtLl9zKF92bS4kdChcIlByZWRpY3RcIikpICsgXCJcXHJcXG4gICAgICBcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDJcbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICA6IF92bS5fZSgpLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX3ZtLmlzTW9kZWxCdWlsZGVkXG4gICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidWkgZmllbGRcIiB9LCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ1aSBwcmltYXJ5IGZsdWlkIGJ1dHRvblwiLFxuICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uc2hvd01vZGVsIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLl92KFwiXFxyXFxuICAgICAgXCIgKyBfdm0uX3MoX3ZtLiR0KFwiU2hvdyBNb2RlbFwiKSkgKyBcIlxcclxcbiAgICBcIildXG4gICAgICAgICAgKVxuICAgICAgICBdKVxuICAgICAgOiBfdm0uX2UoKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIi8qXG4gKiBPcmlnaW5hbCBjb2RlIGZyb206XG4gKlxuICogay1kIFRyZWUgSmF2YVNjcmlwdCAtIFYgMS4wMVxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS91YmlsYWJzL2tkLXRyZWUtamF2YXNjcmlwdFxuICpcbiAqIEBhdXRob3IgTWlyY2VhIFByaWNvcCA8cHJpY29wQHViaWxhYnMubmV0PiwgMjAxMlxuICogQGF1dGhvciBNYXJ0aW4gS2xlcHBlIDxrbGVwcGVAdWJpbGFicy5uZXQ+LCAyMDEyXG4gKiBAYXV0aG9yIFViaWxhYnMgaHR0cDovL3ViaWxhYnMubmV0LCAyMDEyXG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSA8aHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHA+XG4gKi9cblxuZnVuY3Rpb24gTm9kZShvYmosIGRpbWVuc2lvbiwgcGFyZW50KSB7XG4gIHRoaXMub2JqID0gb2JqO1xuICB0aGlzLmxlZnQgPSBudWxsO1xuICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLRFRyZWUge1xuICBjb25zdHJ1Y3Rvcihwb2ludHMsIG1ldHJpYykge1xuICAgIC8vIElmIHBvaW50cyBpcyBub3QgYW4gYXJyYXksIGFzc3VtZSB3ZSdyZSBsb2FkaW5nIGEgcHJlLWJ1aWx0IHRyZWVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0gcG9pbnRzLmRpbWVuc2lvbnM7XG4gICAgICB0aGlzLnJvb3QgPSBwb2ludHM7XG4gICAgICByZXN0b3JlUGFyZW50KHRoaXMucm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBBcnJheShwb2ludHNbMF0ubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc1tpXSA9IGk7XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QgPSBidWlsZFRyZWUocG9pbnRzLCAwLCBudWxsLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIH1cbiAgICB0aGlzLm1ldHJpYyA9IG1ldHJpYztcbiAgfVxuXG4gIC8vIENvbnZlcnQgdG8gYSBKU09OIHNlcmlhbGl6YWJsZSBzdHJ1Y3R1cmU7IHRoaXMganVzdCByZXF1aXJlcyByZW1vdmluZ1xuICAvLyB0aGUgYHBhcmVudGAgcHJvcGVydHlcbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRvSlNPTkltcGwodGhpcy5yb290LCB0cnVlKTtcbiAgICByZXN1bHQuZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgbmVhcmVzdChwb2ludCwgbWF4Tm9kZXMsIG1heERpc3RhbmNlKSB7XG4gICAgY29uc3QgbWV0cmljID0gdGhpcy5tZXRyaWM7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICB2YXIgaTtcblxuICAgIGNvbnN0IGJlc3ROb2RlcyA9IG5ldyBCaW5hcnlIZWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gLWVbMV07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBuZWFyZXN0U2VhcmNoKG5vZGUpIHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGRpbWVuc2lvbnNbbm9kZS5kaW1lbnNpb25dO1xuICAgICAgY29uc3Qgb3duRGlzdGFuY2UgPSBtZXRyaWMocG9pbnQsIG5vZGUub2JqKTtcbiAgICAgIGNvbnN0IGxpbmVhclBvaW50ID0ge307XG4gICAgICB2YXIgYmVzdENoaWxkLCBsaW5lYXJEaXN0YW5jZSwgb3RoZXJDaGlsZCwgaTtcblxuICAgICAgZnVuY3Rpb24gc2F2ZU5vZGUobm9kZSwgZGlzdGFuY2UpIHtcbiAgICAgICAgYmVzdE5vZGVzLnB1c2goW25vZGUsIGRpc3RhbmNlXSk7XG4gICAgICAgIGlmIChiZXN0Tm9kZXMuc2l6ZSgpID4gbWF4Tm9kZXMpIHtcbiAgICAgICAgICBiZXN0Tm9kZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPT09IG5vZGUuZGltZW5zaW9uKSB7XG4gICAgICAgICAgbGluZWFyUG9pbnRbZGltZW5zaW9uc1tpXV0gPSBwb2ludFtkaW1lbnNpb25zW2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lYXJQb2ludFtkaW1lbnNpb25zW2ldXSA9IG5vZGUub2JqW2RpbWVuc2lvbnNbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbmVhckRpc3RhbmNlID0gbWV0cmljKGxpbmVhclBvaW50LCBub2RlLm9iaik7XG5cbiAgICAgIGlmIChub2RlLnJpZ2h0ID09PSBudWxsICYmIG5vZGUubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoYmVzdE5vZGVzLnNpemUoKSA8IG1heE5vZGVzIHx8IG93bkRpc3RhbmNlIDwgYmVzdE5vZGVzLnBlZWsoKVsxXSkge1xuICAgICAgICAgIHNhdmVOb2RlKG5vZGUsIG93bkRpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgIGJlc3RDaGlsZCA9IG5vZGUubGVmdDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIGJlc3RDaGlsZCA9IG5vZGUucmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocG9pbnRbZGltZW5zaW9uXSA8IG5vZGUub2JqW2RpbWVuc2lvbl0pIHtcbiAgICAgICAgICBiZXN0Q2hpbGQgPSBub2RlLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmVzdENoaWxkID0gbm9kZS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZWFyZXN0U2VhcmNoKGJlc3RDaGlsZCk7XG5cbiAgICAgIGlmIChiZXN0Tm9kZXMuc2l6ZSgpIDwgbWF4Tm9kZXMgfHwgb3duRGlzdGFuY2UgPCBiZXN0Tm9kZXMucGVlaygpWzFdKSB7XG4gICAgICAgIHNhdmVOb2RlKG5vZGUsIG93bkRpc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBiZXN0Tm9kZXMuc2l6ZSgpIDwgbWF4Tm9kZXMgfHxcbiAgICAgICAgTWF0aC5hYnMobGluZWFyRGlzdGFuY2UpIDwgYmVzdE5vZGVzLnBlZWsoKVsxXVxuICAgICAgKSB7XG4gICAgICAgIGlmIChiZXN0Q2hpbGQgPT09IG5vZGUubGVmdCkge1xuICAgICAgICAgIG90aGVyQ2hpbGQgPSBub2RlLnJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyQ2hpbGQgPSBub2RlLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBuZWFyZXN0U2VhcmNoKG90aGVyQ2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heERpc3RhbmNlKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWF4Tm9kZXM7IGkgKz0gMSkge1xuICAgICAgICBiZXN0Tm9kZXMucHVzaChbbnVsbCwgbWF4RGlzdGFuY2VdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICBuZWFyZXN0U2VhcmNoKHRoaXMucm9vdCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IE1hdGgubWluKG1heE5vZGVzLCBiZXN0Tm9kZXMuY29udGVudC5sZW5ndGgpOyBpICs9IDEpIHtcbiAgICAgIGlmIChiZXN0Tm9kZXMuY29udGVudFtpXVswXSkge1xuICAgICAgICByZXN1bHQucHVzaChbYmVzdE5vZGVzLmNvbnRlbnRbaV1bMF0ub2JqLCBiZXN0Tm9kZXMuY29udGVudFtpXVsxXV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvSlNPTkltcGwoc3JjKSB7XG4gIGNvbnN0IGRlc3QgPSBuZXcgTm9kZShzcmMub2JqLCBzcmMuZGltZW5zaW9uLCBudWxsKTtcbiAgaWYgKHNyYy5sZWZ0KSBkZXN0LmxlZnQgPSB0b0pTT05JbXBsKHNyYy5sZWZ0KTtcbiAgaWYgKHNyYy5yaWdodCkgZGVzdC5yaWdodCA9IHRvSlNPTkltcGwoc3JjLnJpZ2h0KTtcbiAgcmV0dXJuIGRlc3Q7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShwb2ludHMsIGRlcHRoLCBwYXJlbnQsIGRpbWVuc2lvbnMpIHtcbiAgY29uc3QgZGltID0gZGVwdGggJSBkaW1lbnNpb25zLmxlbmd0aDtcblxuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHBvaW50c1swXSwgZGltLCBwYXJlbnQpO1xuICB9XG5cbiAgcG9pbnRzLnNvcnQoKGEsIGIpID0+IGFbZGltZW5zaW9uc1tkaW1dXSAtIGJbZGltZW5zaW9uc1tkaW1dXSk7XG5cbiAgY29uc3QgbWVkaWFuID0gTWF0aC5mbG9vcihwb2ludHMubGVuZ3RoIC8gMik7XG4gIGNvbnN0IG5vZGUgPSBuZXcgTm9kZShwb2ludHNbbWVkaWFuXSwgZGltLCBwYXJlbnQpO1xuICBub2RlLmxlZnQgPSBidWlsZFRyZWUocG9pbnRzLnNsaWNlKDAsIG1lZGlhbiksIGRlcHRoICsgMSwgbm9kZSwgZGltZW5zaW9ucyk7XG4gIG5vZGUucmlnaHQgPSBidWlsZFRyZWUocG9pbnRzLnNsaWNlKG1lZGlhbiArIDEpLCBkZXB0aCArIDEsIG5vZGUsIGRpbWVuc2lvbnMpO1xuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlUGFyZW50KHJvb3QpIHtcbiAgaWYgKHJvb3QubGVmdCkge1xuICAgIHJvb3QubGVmdC5wYXJlbnQgPSByb290O1xuICAgIHJlc3RvcmVQYXJlbnQocm9vdC5sZWZ0KTtcbiAgfVxuXG4gIGlmIChyb290LnJpZ2h0KSB7XG4gICAgcm9vdC5yaWdodC5wYXJlbnQgPSByb290O1xuICAgIHJlc3RvcmVQYXJlbnQocm9vdC5yaWdodCk7XG4gIH1cbn1cblxuLy8gQmluYXJ5IGhlYXAgaW1wbGVtZW50YXRpb24gZnJvbTpcbi8vIGh0dHA6Ly9lbG9xdWVudGphdmFzY3JpcHQubmV0L2FwcGVuZGl4Mi5odG1sXG5jbGFzcyBCaW5hcnlIZWFwIHtcbiAgY29uc3RydWN0b3Ioc2NvcmVGdW5jdGlvbikge1xuICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgIHRoaXMuc2NvcmVGdW5jdGlvbiA9IHNjb3JlRnVuY3Rpb247XG4gIH1cblxuICBwdXNoKGVsZW1lbnQpIHtcbiAgICAvLyBBZGQgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHRoaXMuY29udGVudC5wdXNoKGVsZW1lbnQpO1xuICAgIC8vIEFsbG93IGl0IHRvIGJ1YmJsZSB1cC5cbiAgICB0aGlzLmJ1YmJsZVVwKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHBvcCgpIHtcbiAgICAvLyBTdG9yZSB0aGUgZmlyc3QgZWxlbWVudCBzbyB3ZSBjYW4gcmV0dXJuIGl0IGxhdGVyLlxuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XG4gICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxuICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IHNpbmsgZG93bi5cbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29udGVudFswXSA9IGVuZDtcbiAgICAgIHRoaXMuc2lua0Rvd24oMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbMF07XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICB9XG5cbiAgYnViYmxlVXAobikge1xuICAgIC8vIEZldGNoIHRoZSBlbGVtZW50IHRoYXQgaGFzIHRvIGJlIG1vdmVkLlxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dO1xuICAgIC8vIFdoZW4gYXQgMCwgYW4gZWxlbWVudCBjYW4gbm90IGdvIHVwIGFueSBmdXJ0aGVyLlxuICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgY29uc3QgcGFyZW50TiA9IE1hdGguZmxvb3IoKG4gKyAxKSAvIDIpIC0gMTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuY29udGVudFtwYXJlbnROXTtcbiAgICAgIC8vIFN3YXAgdGhlIGVsZW1lbnRzIGlmIHRoZSBwYXJlbnQgaXMgZ3JlYXRlci5cbiAgICAgIGlmICh0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkge1xuICAgICAgICB0aGlzLmNvbnRlbnRbcGFyZW50Tl0gPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XG4gICAgICAgIC8vIFVwZGF0ZSAnbicgdG8gY29udGludWUgYXQgdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgbiA9IHBhcmVudE47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3VuZCBhIHBhcmVudCB0aGF0IGlzIGxlc3MsIG5vIG5lZWQgdG8gbW92ZSBpdCBmdXJ0aGVyLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzaW5rRG93bihuKSB7XG4gICAgLy8gTG9vayB1cCB0aGUgdGFyZ2V0IGVsZW1lbnQgYW5kIGl0cyBzY29yZS5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXTtcbiAgICB2YXIgZWxlbVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIGluZGljZXMgb2YgdGhlIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpICogMjtcbiAgICAgIHZhciBjaGlsZDFOID0gY2hpbGQyTiAtIDE7XG4gICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCxcbiAgICAgIC8vIGlmIGFueS5cbiAgICAgIHZhciBzd2FwID0gbnVsbDtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXG4gICAgICBpZiAoY2hpbGQxTiA8IGxlbmd0aCkge1xuICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cbiAgICAgICAgdmFyIGNoaWxkMSA9IHRoaXMuY29udGVudFtjaGlsZDFOXTtcbiAgICAgICAgdmFyIGNoaWxkMVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMSk7XG4gICAgICAgIC8vIElmIHRoZSBzY29yZSBpcyBsZXNzIHRoYW4gb3VyIGVsZW1lbnQncywgd2UgbmVlZCB0byBzd2FwLlxuICAgICAgICBpZiAoY2hpbGQxU2NvcmUgPCBlbGVtU2NvcmUpIHtcbiAgICAgICAgICBzd2FwID0gY2hpbGQxTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG8gdGhlIHNhbWUgY2hlY2tzIGZvciB0aGUgb3RoZXIgY2hpbGQuXG4gICAgICBpZiAoY2hpbGQyTiA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgY2hpbGQyID0gdGhpcy5jb250ZW50W2NoaWxkMk5dO1xuICAgICAgICB2YXIgY2hpbGQyU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQyKTtcbiAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT09IG51bGwgPyBlbGVtU2NvcmUgOiBjaGlsZDFTY29yZSkpIHtcbiAgICAgICAgICBzd2FwID0gY2hpbGQyTjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBuZWVkcyB0byBiZSBtb3ZlZCwgc3dhcCBpdCwgYW5kIGNvbnRpbnVlLlxuICAgICAgaWYgKHN3YXAgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50W25dID0gdGhpcy5jb250ZW50W3N3YXBdO1xuICAgICAgICB0aGlzLmNvbnRlbnRbc3dhcF0gPSBlbGVtZW50O1xuICAgICAgICBuID0gc3dhcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgYXJlIGRvbmUuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIGFzIGV1Y2xpZGVhbkRpc3RhbmNlIH0gZnJvbSAnbWwtZGlzdGFuY2UtZXVjbGlkZWFuJztcblxuaW1wb3J0IEtEVHJlZSBmcm9tICcuL0tEVHJlZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtOTiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGxhYmVsc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaz1udW1iZXJPZkNsYXNzZXMgKyAxXSAtIE51bWJlciBvZiBuZWlnaGJvcnMgdG8gY2xhc3NpZnkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmRpc3RhbmNlPWV1Y2xpZGVhbkRpc3RhbmNlXSAtIERpc3RhbmNlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdHdvIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhc2V0LCBsYWJlbHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChkYXRhc2V0ID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBtb2RlbCA9IGxhYmVscztcbiAgICAgIHRoaXMua2RUcmVlID0gbmV3IEtEVHJlZShtb2RlbC5rZFRyZWUsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5rID0gbW9kZWwuaztcbiAgICAgIHRoaXMuY2xhc3NlcyA9IG5ldyBTZXQobW9kZWwuY2xhc3Nlcyk7XG4gICAgICB0aGlzLmlzRXVjbGlkZWFuID0gbW9kZWwuaXNFdWNsaWRlYW47XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NlcyA9IG5ldyBTZXQobGFiZWxzKTtcblxuICAgIGNvbnN0IHsgZGlzdGFuY2UgPSBldWNsaWRlYW5EaXN0YW5jZSwgayA9IGNsYXNzZXMuc2l6ZSArIDEgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkoZGF0YXNldC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwb2ludHNbaV0gPSBkYXRhc2V0W2ldLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgcG9pbnRzW2ldLnB1c2gobGFiZWxzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLmtkVHJlZSA9IG5ldyBLRFRyZWUocG9pbnRzLCBkaXN0YW5jZSk7XG4gICAgdGhpcy5rID0gaztcbiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzO1xuICAgIHRoaXMuaXNFdWNsaWRlYW4gPSBkaXN0YW5jZSA9PT0gZXVjbGlkZWFuRGlzdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEtOTiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBtb2RlbC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpc3RhbmNlPWV1Y2xpZGVhbkRpc3RhbmNlIC0gZGlzdGFuY2UgZnVuY3Rpb24gbXVzdCBiZSBwcm92aWRlZCBpZiB0aGUgbW9kZWwgd2Fzbid0IHRyYWluZWQgd2l0aCBldWNsaWRlYW4gZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge0tOTn1cbiAgICovXG4gIHN0YXRpYyBsb2FkKG1vZGVsLCBkaXN0YW5jZSA9IGV1Y2xpZGVhbkRpc3RhbmNlKSB7XG4gICAgaWYgKG1vZGVsLm5hbWUgIT09ICdLTk4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbW9kZWw6ICR7bW9kZWwubmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKCFtb2RlbC5pc0V1Y2xpZGVhbiAmJiBkaXN0YW5jZSA9PT0gZXVjbGlkZWFuRGlzdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2EgY3VzdG9tIGRpc3RhbmNlIGZ1bmN0aW9uIHdhcyB1c2VkIHRvIGNyZWF0ZSB0aGUgbW9kZWwuIFBsZWFzZSBwcm92aWRlIGl0IGFnYWluJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1vZGVsLmlzRXVjbGlkZWFuICYmIGRpc3RhbmNlICE9PSBldWNsaWRlYW5EaXN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndGhlIG1vZGVsIHdhcyBjcmVhdGVkIHdpdGggdGhlIGRlZmF1bHQgZGlzdGFuY2UgZnVuY3Rpb24uIERvIG5vdCBsb2FkIGl0IHdpdGggYW5vdGhlciBvbmUnXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEtOTih0cnVlLCBtb2RlbCwgZGlzdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIEpTT04gY29udGFpbmluZyB0aGUga2QtdHJlZSBtb2RlbC5cbiAgICogQHJldHVybiB7b2JqZWN0fSBKU09OIEtOTiBtb2RlbC5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ0tOTicsXG4gICAgICBrZFRyZWU6IHRoaXMua2RUcmVlLFxuICAgICAgazogdGhpcy5rLFxuICAgICAgY2xhc3NlczogQXJyYXkuZnJvbSh0aGlzLmNsYXNzZXMpLFxuICAgICAgaXNFdWNsaWRlYW46IHRoaXMuaXNFdWNsaWRlYW5cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFByZWRpY3RzIHRoZSBvdXRwdXQgZ2l2ZW4gdGhlIG1hdHJpeCB0byBwcmVkaWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhc2V0XG4gICAqIEByZXR1cm4ge0FycmF5fSBwcmVkaWN0aW9uc1xuICAgKi9cbiAgcHJlZGljdChkYXRhc2V0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YXNldCkpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldFswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpbmdsZVByZWRpY3Rpb24odGhpcywgZGF0YXNldCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KGRhdGFzZXRbMF0pICYmXG4gICAgICAgIHR5cGVvZiBkYXRhc2V0WzBdWzBdID09PSAnbnVtYmVyJ1xuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb25zID0gbmV3IEFycmF5KGRhdGFzZXQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcHJlZGljdGlvbnNbaV0gPSBnZXRTaW5nbGVQcmVkaWN0aW9uKHRoaXMsIGRhdGFzZXRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVkaWN0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YXNldCB0byBwcmVkaWN0IG11c3QgYmUgYW4gYXJyYXkgb3IgYSBtYXRyaXgnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTaW5nbGVQcmVkaWN0aW9uKGtubiwgY3VycmVudENhc2UpIHtcbiAgdmFyIG5lYXJlc3RQb2ludHMgPSBrbm4ua2RUcmVlLm5lYXJlc3QoY3VycmVudENhc2UsIGtubi5rKTtcbiAgdmFyIHBvaW50c1BlckNsYXNzID0ge307XG4gIHZhciBwcmVkaWN0ZWRDbGFzcyA9IC0xO1xuICB2YXIgbWF4UG9pbnRzID0gLTE7XG4gIHZhciBsYXN0RWxlbWVudCA9IG5lYXJlc3RQb2ludHNbMF1bMF0ubGVuZ3RoIC0gMTtcblxuICBmb3IgKHZhciBlbGVtZW50IG9mIGtubi5jbGFzc2VzKSB7XG4gICAgcG9pbnRzUGVyQ2xhc3NbZWxlbWVudF0gPSAwO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWFyZXN0UG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGN1cnJlbnRDbGFzcyA9IG5lYXJlc3RQb2ludHNbaV1bMF1bbGFzdEVsZW1lbnRdO1xuICAgIHZhciBjdXJyZW50UG9pbnRzID0gKytwb2ludHNQZXJDbGFzc1tjdXJyZW50Q2xhc3NdO1xuICAgIGlmIChjdXJyZW50UG9pbnRzID4gbWF4UG9pbnRzKSB7XG4gICAgICBwcmVkaWN0ZWRDbGFzcyA9IGN1cnJlbnRDbGFzcztcbiAgICAgIG1heFBvaW50cyA9IGN1cnJlbnRQb2ludHM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZWRpY3RlZENsYXNzO1xufVxuIiwiaW1wb3J0IEtOTiBmcm9tICdtbC1rbm4nXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoS05lYXJlc3ROZWlnaGJvcnMpIHtcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLnN0YXJ0UHJlZGljdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0KClcclxuICB9XHJcbiAgICBcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLnN0YXJ0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgLy90aGlzLmxvY2FsQ29uZmlnLm1vZGVsSlNPTiA9IG51bGxcclxuICAgIHRoaXMuY29uZmlnLmxvYWRpbmdQcm9ncmVzcyA9IDBcclxuICAgIGNvbnNvbGUubG9nKCdzdGFydCcsIDEpXHJcbiAgICBcclxuICAgIHRoaXMubG9jYWxDb25maWcubW9kZWxKU09OID0gbnVsbFxyXG4gICAgdGhpcy5sb2NhbENvbmZpZy5tb2RlbEV2YWx1YXRpb25zID0gW11cclxuICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy4kcGFyZW50LmdldFZlY3RvckRhdGEoKVxyXG4gICAgXHJcbiAgICB0aGlzLmRhdGFUb1Nob3cgPSBkYXRhXHJcbiAgICBcclxuICAgIGlmIChkYXRhLnRyYWluU2V0Q2xhc3Nlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTm8gdHJhaW5TZXRDbGFzc2VzJylcclxuICAgICAgLy90aHJvdyBFcnJvcignTm8gdHJhaW5TZXRDbGFzc2VzJylcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coZGF0YSlcclxuICAgIC8vcmV0dXJuIGZhbHNlXHJcbiAgICB0aGlzLmNvbmZpZy5sb2FkaW5nUHJvZ3Jlc3MgPSAwLjI1XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdzdGFydCcsIDIpXHJcbiAgICAvL2NvbnNvbGUubG9nKGRhdGEudHJhaW5TZXRbMF0pXHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdzdGFydCcsIDMpXHJcbiAgICBpZiAoZGF0YS50cmFpblNldENsYXNzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBpZiAoIXRoaXMubG9jYWxDb25maWcubW9kZWxKU09OKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuYnVpbGRNb2RlbChkYXRhKVxyXG4gICAgICAgIHRoaXMubG9jYWxDb25maWcubW9kZWxKU09OID0gdGhpcy5tb2RlbFxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBLTk4ubG9hZCh0aGlzLmxvY2FsQ29uZmlnLm1vZGVsSlNPTilcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm1vZGVsLnRvSlNPTigpKVxyXG5cclxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm1vZGVsKVxyXG4gICAgICBjb25zb2xlLmxvZygnc3RhcnQnLCA1KVxyXG5cclxuICAgICAgdGhpcy5jb25maWcubG9hZGluZ1Byb2dyZXNzID0gMC41XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnc3RhcnQnLCA5KVxyXG4gICAgICAvL2NvbnNvbGUubG9nKGRhdGEudGVzdFNldClcclxuICAgICAgbGV0IHByZWRpY3RWZWN0b3IgPSBhd2FpdCB0aGlzLmdldFByZWRpY3RSZXN1bHRzVmVjdG9yKHRoaXMubW9kZWwsIGRhdGEpXHJcbiAgICAgIGxldCBwcmVkaWN0UmVzdWx0cyA9IGF3YWl0IHRoaXMuZ2V0UHJlZGljdFJlc3VsdHNWYWx1ZShkYXRhLCBwcmVkaWN0VmVjdG9yKVxyXG4gICAgICBjb25zb2xlLmxvZyhwcmVkaWN0VmVjdG9yKVxyXG4gICAgICBpZiAocHJlZGljdFJlc3VsdHNbMF0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcubG9hZGluZ1Byb2dyZXNzID0gMVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3ByZWRpY3QgaXMgdW5kZWZpbmVkJylcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ3N0YXJ0JywgMTApXHJcbiAgICAgIHRoaXMuY29uZmlnLmxvYWRpbmdQcm9ncmVzcyA9IDAuNzVcclxuXHJcbiAgICAgIGlmICh0aGlzLiRwYXJlbnQuaGFzTW9kZWxFdmFsdWF0ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IHRlc3RTZXRSb3dJbmRleGVzID0gZGF0YS50ZXN0U2V0Um93SW5kZXhlc1xyXG4gICAgICAgIHRoaXMudW5rbm93bnNQcmVkaWN0aW9uID0gW11cclxuICAgICAgICBsZXQgcHJlZGljdFZlY3RvclRvRXZhbHV0ZSA9IHByZWRpY3RWZWN0b3IuZmlsdGVyKCh2YWx1ZSwgaSkgPT4ge1xyXG4gICAgICAgICAgbGV0IG5vdE1hdGNoID0gKHRlc3RTZXRSb3dJbmRleGVzLmluZGV4T2YoaSkgPT09IC0xKVxyXG5cclxuICAgICAgICAgIGlmIChub3RNYXRjaCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy51bmtub3duc1ByZWRpY3Rpb24ucHVzaCh2YWx1ZSlcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gbm90TWF0Y2hcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuZXZhbHVhdGlvblJlc3VsdHMoZGF0YS50cmFpblNldENsYXNzZXMsIHByZWRpY3RWZWN0b3JUb0V2YWx1dGUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vY29uc29sZS5sb2cocHJlZGljdFJlc3VsdHMpXHJcbiAgICAgIHRoaXMuJHBhcmVudC5zZXRQcmVkaWN0UmVzdWx0cyhwcmVkaWN0UmVzdWx0cylcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnLmxvYWRpbmdQcm9ncmVzcyA9IDAuOVxyXG5cclxuICAgIH0gLy8gaWYgKGRhdGEudHJhaW5TZXRDbGFzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGlzLm1vZGVsID0gJ3Vuc3VwZXJ2aXNlZCdcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuJHBhcmVudC5pc01vZGVsV2luZG93T3BlbmVkKSB7XHJcbiAgICAgIHRoaXMuc2hvd01vZGVsKClcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5jb25maWcubG9hZGluZ1Byb2dyZXNzID0gMVxyXG4gICAgdGhpcy5jb25maWcubW9kZWxCdWlsZGVkVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKClcclxuICB9XHJcbiAgXHJcbiAgS05lYXJlc3ROZWlnaGJvcnMubWV0aG9kcy5idWlsZE1vZGVsID0gZnVuY3Rpb24gKGRhdGEpe1xyXG4gICAgbGV0IHRlc3RTZXRSb3dJbmRleGVzID0gZGF0YS50ZXN0U2V0Um93SW5kZXhlc1xyXG4gICAgbGV0IGRhdGFzZXQgPSBkYXRhLnRlc3RTZXQuZmlsdGVyKChyb3csIGkpID0+IHtcclxuICAgICAgcmV0dXJuICh0ZXN0U2V0Um93SW5kZXhlcy5pbmRleE9mKGkpID09PSAtMSlcclxuICAgIH0pXHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGRhdGFzZXQpXHJcbiAgICBsZXQgcHJlZGljdGlvbnMgPSBkYXRhLnRyYWluU2V0Q2xhc3Nlc1xyXG4gICAgXHJcbiAgICBpZiAoZGF0YXNldC5sZW5ndGggPT09IDApIHtcclxuICAgICAgZGF0YXNldCA9IGRhdGEudGVzdFNldFxyXG4gICAgICBwcmVkaWN0aW9ucyA9IGRhdGFzZXQubWFwKGl0ZW0gPT4gJ3Vua25vd24nKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoZGF0YXNldC5sZW5ndGggIT09IHByZWRpY3Rpb25zLmxlbmd0aCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdsZW5ndGggaXMgbm90IG1hdGNoJylcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBLTk4oZGF0YXNldCwgcHJlZGljdGlvbnMsIHtcclxuICAgICAgazogdGhpcy5sb2NhbENvbmZpZy5LTmVhcmVzdE5laWdoYm9yc09wdGlvbnNLXHJcbiAgICB9KVxyXG4gIH1cclxuICBcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLmdldFByZWRpY3RSZXN1bHRzVmVjdG9yID0gYXN5bmMgZnVuY3Rpb24gKG1vZGVsLCBkYXRhKSB7XHJcbiAgICBsZXQgdGVzdFNldCA9IGRhdGEudGVzdFNldFxyXG4gICAgbGV0IHJlc3VsdFZlY3RvciA9IG1vZGVsLnByZWRpY3QodGVzdFNldCk7XHJcbiAgICByZXR1cm4gcmVzdWx0VmVjdG9yXHJcbiAgfVxyXG4gIFxyXG4gIEtOZWFyZXN0TmVpZ2hib3JzLm1ldGhvZHMuZ2V0UHJlZGljdFJlc3VsdHNWYWx1ZSA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhLCByZXN1bHRWZWN0b3IpIHtcclxuICAgIGxldCB0cmFpblNldENsYXNzZXNEaWN0ID0gZGF0YS50cmFpblNldENsYXNzZXNEaWN0XHJcbiAgICAvL2NvbnNvbGUubG9nKHRyYWluU2V0Q2xhc3Nlc0RpY3QpXHJcbiAgICByZXR1cm4gcmVzdWx0VmVjdG9yLm1hcChpbmRleCA9PiB7XHJcbiAgICAgIHJldHVybiB0cmFpblNldENsYXNzZXNEaWN0W2luZGV4XVxyXG4gICAgfSlcclxuICB9XHJcbiAgXHJcbiAgS05lYXJlc3ROZWlnaGJvcnMubWV0aG9kcy5ldmFsdWF0aW9uUmVzdWx0cyA9IGFzeW5jIGZ1bmN0aW9uICh0cmFpbiwgcHJlZGljdCkge1xyXG4gICAgXHJcbiAgICB0aGlzLiRwYXJlbnQucmVzZXRNb2RlbEV2YWx1YXRpb24oKVxyXG4gICAgY29uc29sZS5sb2codHJhaW4pXHJcbiAgICBjb25zb2xlLmxvZyhwcmVkaWN0KVxyXG4gICAgLy9jb25zb2xlLmxvZyhkYXRhLnRyYWluU2V0Q2xhc3Nlcy5sZW5ndGgsIGdldFRyYWluU2V0UHJlZGljdHMubGVuZ3RoLCBkYXRhLnRlc3RTZXRSb3dJbmRleGVzLmxlbmd0aClcclxuXHJcbiAgICBsZXQgYWNjdXJhY3kgPSBhd2FpdCB0aGlzLiRwYXJlbnQuY2FsY0FjY3VyYWN5KHRyYWluLCBwcmVkaWN0KVxyXG4gICAgLy9jb25zb2xlLmxvZyhhY2N1cmFjeSlcclxuICAgIGxldCBhY2N1cmFjeUluZm8gPSB7XHJcbiAgICAgIG5hbWU6ICdhY2N1cmFjeScsXHJcbiAgICAgIHR5cGU6ICdwZXJjZW50JyxcclxuICAgICAgdmFsdWU6IGFjY3VyYWN5XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vY29uc29sZS5sb2coYWNjdXJhY3lJbmZvKVxyXG4gICAgdGhpcy5sb2NhbENvbmZpZy5tb2RlbEV2YWx1YXRpb25zLnB1c2goYWNjdXJhY3lJbmZvKVxyXG4gIH1cclxufSIsIi8vaW1wb3J0IHtldWNsaWRlYW59IGZyb20gJ21sLWRpc3RhbmNlLWV1Y2xpZGVhbidcclxuY29uc3QgZXVjbGlkZWFuID0gcmVxdWlyZSgnbWwtZGlzdGFuY2UtZXVjbGlkZWFuJykuZXVjbGlkZWFuXHJcbi8vY29uc3QgZXVjbGlkZWFuID0gTUxEaXN0YW5jZUV1Y2xpZGVhbi5ldWNsaWRlYW5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChLTmVhcmVzdE5laWdoYm9ycykge1xyXG4gIEtOZWFyZXN0TmVpZ2hib3JzLm1ldGhvZHMuc2hvd01vZGVsID0gYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLm1vZGVsKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnQoKVxyXG4gICAgICAvL2NvbnNvbGUuZXJyb3IoJ25vIHRoaXMubW9kZWwnKVxyXG4gICAgICAvL3JldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvL2NvbnNvbGUubG9nKHRoaXMuZGF0YVRvU2hvdylcclxuICAgIGxldCB1bmtub3duU2V0Um93SW5kZXggPSB0aGlzLmRhdGFUb1Nob3cudGVzdFNldFJvd0luZGV4ZXNcclxuXHJcbiAgICBsZXQgbmVpZ2hib3JzID0gW11cclxuICAgIGxldCBuZWlnaGJvcnNJRCA9IFtdXHJcbiAgICBsZXQgdW5rbm93bnMgPSBbXVxyXG4gICAgbGV0IHVua25vd25zSUQgPSBbXVxyXG4gICAgLy9jb25zb2xlLmxvZyh1bmtub3duU2V0Um93SW5kZXgpXHJcblxyXG4gICAgdGhpcy5kYXRhVG9TaG93LnRlc3RTZXQuZm9yRWFjaCgoc2V0LCBpKSA9PiB7XHJcbiAgICAgIGlmICh1bmtub3duU2V0Um93SW5kZXguaW5kZXhPZihpKSA9PT0gLTEpIHtcclxuICAgICAgICBuZWlnaGJvcnMucHVzaChzZXQpXHJcbiAgICAgICAgbmVpZ2hib3JzSUQucHVzaChpKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVua25vd25zLnB1c2goc2V0KVxyXG4gICAgICAgIHVua25vd25zSUQucHVzaChpKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vY29uc29sZS5sb2cobmVpZ2hib3JzKVxyXG4gICAgLy9jb25zb2xlLmxvZyh1bmtub3ducylcclxuICAgIGlmIChuZWlnaGJvcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIG5laWdoYm9ycyA9IHVua25vd25zXHJcbiAgICAgIG5laWdoYm9yc0lEID0gdW5rbm93bnNJRFxyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBsZXQgZGlzdGFuY2VNYXRyaXggPSB1bmtub3ducy5tYXAodW5rbm93bkZlYXR1cmUgPT4ge1xyXG4gICAgICBsZXQgbWF4RGlzdGFuY2UgPSBudWxsXHJcbiAgICAgIGxldCBkaXN0YW5jZXMgPSBuZWlnaGJvcnMubWFwKG5laWdoYm9yID0+IHtcclxuICAgICAgICBsZXQgZGlzdGFuY2UgPSBldWNsaWRlYW4odW5rbm93bkZlYXR1cmUsIG5laWdoYm9yKVxyXG4gICAgICAgIGlmIChtYXhEaXN0YW5jZSA9PT0gbnVsbCB8fCBkaXN0YW5jZSA+IG1heERpc3RhbmNlKSB7XHJcbiAgICAgICAgICBtYXhEaXN0YW5jZSA9IGRpc3RhbmNlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGlzdGFuY2VcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGRpc3RhbmNlcyA9IGRpc3RhbmNlcy5tYXAoZCA9PiB7XHJcbiAgICAgICAgcmV0dXJuICgobWF4RGlzdGFuY2UgLSBkKSAvIG1heERpc3RhbmNlKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgcmV0dXJuIGRpc3RhbmNlc1xyXG4gICAgfSlcclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKGRpc3RhbmNlTWF0cml4KVxyXG5cclxuICAgIGxldCBjb2xvck1hdHJpeCA9IGRpc3RhbmNlTWF0cml4Lm1hcCh1bmtub3duID0+IHtcclxuICAgICAgcmV0dXJuIHVua25vd24ubWFwKGQgPT4ge1xyXG4gICAgICAgIHJldHVybiBoZWF0TWFwQ29sb3Jmb3JWYWx1ZShkKVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKGNvbG9yTWF0cml4KVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgbGV0IHRhYmxlSGVhZGVyVW5rbm93bkNvbHNwYW4gPSAyXHJcbiAgICBpZiAodGhpcy5tb2RlbCA9PT0gJ3Vuc3VwZXJ2aXNlZCcpIHtcclxuICAgICAgdGFibGVIZWFkZXJVbmtub3duQ29sc3BhbiA9IDFcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdGFibGVIZWFkZXIgPSBgPHRoZWFkPlxyXG4gIDx0cj5cclxuICAgIDx0aCByb3dzcGFuPVwiMlwiIGNvbHNwYW49XCIke3RhYmxlSGVhZGVyVW5rbm93bkNvbHNwYW59XCIgdmFsaWduPVwiYm90dG9tXCI+JHt0aGlzLiR0KCdVbmtub3ducycpfTwvdGg+XHJcbiAgICA8dGggY29sc3Bhbj1cIiR7Y29sb3JNYXRyaXhbMF0ubGVuZ3RofVwiPiR7dGhpcy4kdCgnTmVpZ2hib3JzJyl9PC90aD5cclxuICA8L3RyPlxyXG4gIDx0cj4ke2NvbG9yTWF0cml4WzBdLm1hcCgodmFsdWUsIGkpID0+IGA8dGg+JHtuZWlnaGJvcnNJRFtpXSArIDF9PC90aD5gKS5qb2luKCcnKX08L3RyPlxyXG48L3RoZWFkPmBcclxuXHJcbiAgICBsZXQgdHJhaW5TZXRDbGFzc2VzRGljdCA9IHRoaXMuZGF0YVRvU2hvdy50cmFpblNldENsYXNzZXNEaWN0XHJcblxyXG4gICAgbGV0IHRhYmxlQm9keSA9IGA8dGJvZHk+XHJcbiR7Y29sb3JNYXRyaXgubWFwKChyb3csIGkpID0+IHtcclxuICAgICAgbGV0IHRoUHJlZGllY3Rpb24gPSBgPHRoPiR7dHJhaW5TZXRDbGFzc2VzRGljdFt0aGlzLnVua25vd25zUHJlZGljdGlvbltpXV19PC90aD5gXHJcbiAgICAgIGlmICh0aGlzLm1vZGVsID09PSAndW5zdXBlcnZpc2VkJykge1xyXG4gICAgICAgIHRoUHJlZGllY3Rpb24gPSAnJ1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBgPHRyPlxyXG4gIDx0aD4keyh1bmtub3duU2V0Um93SW5kZXhbaV0pICsgMX08L3RoPlxyXG4gICR7dGhQcmVkaWVjdGlvbn1cclxuICAke3Jvdy5tYXAoKGNvbG9yLCBqKSA9PiB7XHJcbiAgICAgICAgbGV0IGQgPSBkaXN0YW5jZU1hdHJpeFtpXVtqXVxyXG4gICAgICAgIGxldCBkVGV4dCA9IGRcclxuICAgICAgICBkVGV4dCA9IE1hdGgucm91bmQoZFRleHQgKiAxMDApICsgJyUnXHJcblxyXG4gICAgICAgIGlmIChkID4gMC43IHx8IGQgPCAwLjMpIHtcclxuICAgICAgICAgIHJldHVybiBgPHRkIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjogJHtjb2xvcn07IGNvbG9yOiB3aGl0ZVwiPiR7ZFRleHR9PC90ZD5gXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBgPHRkIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjogJHtjb2xvcn1cIj4ke2RUZXh0fTwvdGQ+YFxyXG4gICAgICAgIH1cclxuICAgICAgfSkuam9pbignJyl9XHJcbjwvdHI+YFxyXG4gICAgfSkuam9pbignXFxuJyl9XHJcbjwvdGJvZHk+YFxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgbGV0IGJvZHlIVE1MID0gYDx0YWJsZSBib3JkZXI9XCIxXCIgYWxpZ249XCJjZW50ZXJcIj5cclxuICAgICR7dGFibGVIZWFkZXJ9XHJcbiAgICAke3RhYmxlQm9keX1cclxuPC90YWJsZT5gXHJcbiAgICBib2R5SFRNTCA9IGA8ZGl2IGNsYXNzPVwidHJlZVwiPiR7Ym9keUhUTUx9PC9kaXY+YFxyXG4gICAgLy9jb25zb2xlLmVycm9yKCdbVE9ET10nKVxyXG4gICAgLy9jb25zb2xlLmxvZygpXHJcbiAgICBsZXQgdGl0bGUgPSB0aGlzLiR0KCdLTk4nKSArIGAgKGAgKyAobmV3IERhdGUoKSkubW1kZGhobW0oKSArICcpJ1xyXG5cclxuICAgIC8vY29uc29sZS5sb2coJ0tOTk1vZGVsU2hvdycgKyB0aGlzLmNvbmZpZy5tb2RlbEJ1aWxkZWRUaW1lKVxyXG4gICAgbGV0IG1vZGVsV2luZG93ID0gdGhpcy51dGlscy5Qb3B1cFV0aWxzLm9wZW4oe1xyXG4gICAgICB3aW5kb3dOYW1lOiAnS05OTW9kZWxTaG93JyArIHRoaXMuY29uZmlnLm1vZGVsQnVpbGRlZFRpbWUsXHJcbiAgICAgIGNzc1VSTDogdGhpcy5tb2RlbENTU1VSTCxcclxuICAgICAgYm9keUhUTUwsXHJcbiAgICAgIHNpemU6ICdyaWdodCcsXHJcbiAgICAgIC8vc2l6ZTogJ2xlZnQnLFxyXG4gICAgICB0aXRsZVxyXG4gICAgfSlcclxuXHJcbiAgICBtb2RlbFdpbmRvdy5zY3JvbGxUb1RvcCgpXHJcbiAgICBtb2RlbFdpbmRvdy5zY3JvbGxUb0NlbnRlcigpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjcyNjM5MTgvNjY0NTM5OVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGhlYXRNYXBDb2xvcmZvclZhbHVlKHZhbHVlKSB7XHJcbiAgICB2YXIgaCA9ICgxLjAgLSB2YWx1ZSkgKiAyNDBcclxuICAgIHJldHVybiBcImhzbChcIiArIGggKyBcIiwgMTAwJSwgNTAlKVwiO1xyXG4gICAgLy9yZXR1cm4gYHJnYmEoMjIsIDE2MCwgMTMzLCAke3ZhbHVlfSlgXHJcbiAgICAvLyByZ2IoMjIsIDE2MCwgMTMzKVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgS05OIGZyb20gJ21sLWtubidcclxuLy8gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWwta25uXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoS05lYXJlc3ROZWlnaGJvcnMpIHtcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLnRlc3RLTk4gPSBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZGF0YXNldCA9IFtcclxuICAgICAgWzAsIDAsIDBdLFxyXG4gICAgICBbMCwgMSwgMV0sXHJcbiAgICAgIFsxLCAxLCAwXSxcclxuICAgICAgWzIsIDIsIDJdLFxyXG4gICAgICBbMSwgMiwgMl0sXHJcbiAgICAgIFsyLCAxLCAyXVxyXG4gICAgXTtcclxuICAgIHZhciBwcmVkaWN0aW9ucyA9IFswLCAwLCAwLCAxLCAxLCAxXTtcclxuICAgIHZhciBrbm4gPSBuZXcgS05OKGRhdGFzZXQsIHByZWRpY3Rpb25zKTtcclxuICAgIFxyXG4gICAgdmFyIGRhdGFzZXQgPSBbWzAsIDAsIDBdLCBbMiwgMiwgMl1dO1xyXG4gXHJcbiAgICB2YXIgYW5zID0ga25uLnByZWRpY3QoZGF0YXNldCk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGFucylcclxuICB9XHJcbn0iLCJsZXQgS05lYXJlc3ROZWlnaGJvcnMgPSB7XHJcbiAgcHJvcHM6IFsnY29uZmlnJywgJ2xvY2FsQ29uZmlnJywgJ3V0aWxzJ10sXHJcbiAgZGF0YSAoKSB7ICAgIFxyXG4gICAgdGhpcy4kaTE4bi5sb2NhbGUgPSB0aGlzLmxvY2FsQ29uZmlnLmxvY2FsZVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbW9kZWw6IG51bGwsXHJcbiAgICAgIGRhdGFUb1Nob3c6IG51bGwsXHJcbiAgICAgIHVua25vd25zUHJlZGljdGlvbjogW10sXHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgJ2xvY2FsQ29uZmlnLmxvY2FsZScoKSB7XHJcbiAgICAgIHRoaXMuJGkxOG4ubG9jYWxlID0gdGhpcy5sb2NhbENvbmZpZy5sb2NhbGU7XHJcbiAgICB9LFxyXG4gICAgJ2xvY2FsQ29uZmlnLktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0snICgpIHtcclxuICAgICAgdGhpcy4kcGFyZW50LmNsZWFyUHJlZGljdGlvbigpXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgaXNNb2RlbEJ1aWxkZWQgKCkge1xyXG4gICAgICByZXR1cm4gKHRoaXMubW9kZWwgIT09IG51bGwpXHJcbiAgICB9LFxyXG4gICAgaXNNb2RlbFVuc3VwZXJ2aXNlZCAoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5tb2RlbCAhPT0gbnVsbCAmJiB0aGlzLm1vZGVsID09PSAndW5zdXBlcnZpc2VkJylcclxuICAgIH0sXHJcbiAgfSxcclxuICBtb3VudGVkKCkge1xyXG4vLyAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuLy8gICAgICB0aGlzLnN0YXJ0KClcclxuLy8gICAgfSwgMTAwMClcclxuXHJcbiAgICAvL3RoaXMudGVzdEtOTigpXHJcbiAgfSxcclxuICBtZXRob2RzOiB7fVxyXG59XHJcblxyXG5pbXBvcnQgS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzQnVpbGQgZnJvbSAnLi9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNCdWlsZC5qcydcclxuS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzQnVpbGQoS05lYXJlc3ROZWlnaGJvcnMpXHJcblxyXG5pbXBvcnQgS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzU2hvdyBmcm9tICcuL0tOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Nob3cuanMnXHJcbktOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Nob3coS05lYXJlc3ROZWlnaGJvcnMpXHJcblxyXG5pbXBvcnQgS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzVGVzdCBmcm9tICcuL0tOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Rlc3QuanMnXHJcbktOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Rlc3QoS05lYXJlc3ROZWlnaGJvcnMpXHJcblxyXG5leHBvcnQgZGVmYXVsdCBLTmVhcmVzdE5laWdoYm9ycyIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNiEuL0tOZWFyZXN0TmVpZ2hib3JzLmpzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTYhLi9LTmVhcmVzdE5laWdoYm9ycy5qcz92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vS05lYXJlc3ROZWlnaGJvcnMuaHRtbD92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xMjk1MjQ1YyZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9LTmVhcmVzdE5laWdoYm9ycy5qcz92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vS05lYXJlc3ROZWlnaGJvcnMuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vS05lYXJlc3ROZWlnaGJvcnMubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTEyOTUyNDVjJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMTI5NTI0NWNcIixcbiAgbnVsbFxuICBcbilcblxuLyogY3VzdG9tIGJsb2NrcyAqL1xuaW1wb3J0IGJsb2NrMCBmcm9tIFwiLi9LTmVhcmVzdE5laWdoYm9ycy55YW1sP3Z1ZSZ0eXBlPWN1c3RvbSZpbmRleD0wJmJsb2NrVHlwZT1pMThuJmlzc3VlclBhdGg9RSUzQSU1Q3B1ZGRpbmclNUNDb2RlLVBvcmplY3RzJTVDaHRtbC1hcGklNUNIVE1MLVNpbXBsZS1DbGFzc2lmaWVyJTVDc3JjJTVDY29tcG9uZW50cyU1Q0NvbmZpZ3VyYXRpb25QYW5lbCU1Q0tOZWFyZXN0TmVpZ2hib3JzJTVDS05lYXJlc3ROZWlnaGJvcnMudnVlJmxhbmc9eWFtbFwiXG5pZiAodHlwZW9mIGJsb2NrMCA9PT0gJ2Z1bmN0aW9uJykgYmxvY2swKGNvbXBvbmVudClcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJFOlxcXFxwdWRkaW5nXFxcXENvZGUtUG9yamVjdHNcXFxcaHRtbC1hcGlcXFxcSFRNTC1TaW1wbGUtQ2xhc3NpZmllclxcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCcxMjk1MjQ1YycpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCcxMjk1MjQ1YycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCcxMjk1MjQ1YycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vS05lYXJlc3ROZWlnaGJvcnMuaHRtbD92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xMjk1MjQ1YyZzY29wZWQ9dHJ1ZSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCcxMjk1MjQ1YycsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzSEE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTkE7QUFBQTtBQUNBO0FBREE7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBeEJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUVBO0FBQ0E7QUF6Q0E7QUFBQTtBQUNBO0FBREE7QUEwQ0E7QUExQ0E7QUFBQTtBQUNBO0FBREE7QUEyQ0E7QUFDQTtBQUNBO0FBN0NBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUE2Q0E7QUFDQTtBQS9DQTtBQUNBO0FBREE7QUFtREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBeEVBO0FBQUE7QUFDQTtBQURBO0FBNEVBO0FBQ0E7QUE3RUE7QUErRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFDQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQU1BO0FBQ0E7QUFqQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBa0JBOzs7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQS9IQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWlJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7OztBQy9JQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQWpCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWtCQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWpDQTtBQW9DQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUM3Q0E7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBaUJBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///513\n')}}]);