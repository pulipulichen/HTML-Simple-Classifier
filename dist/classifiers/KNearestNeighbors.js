(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{230:function(module,exports,__webpack_require__){eval("var content = __webpack_require__(547);\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(5)(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/ODhjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMyEuL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xMjk1MjQ1YyZsYW5nPWxlc3Mmc2NvcGVkPXRydWUmXCIpO1xuXG5pZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbn1cblxudmFyIG9wdGlvbnMgPSB7fVxuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZiAoY29udGVudC5sb2NhbHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///230\n")},231:function(module,exports){eval('module.exports = function (Component) {\n  Component.options.__i18n = Component.options.__i18n || []\n  Component.options.__i18n.push(\'{"en":{"TEST_MESSAGE":"Test Message"},"zh-TW":{"TEST_MESSAGE":"測試訊息"}}\')\n  delete Component.options._Ctor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLnlhbWw/ZTc2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuID0gQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuIHx8IFtdXG4gIENvbXBvbmVudC5vcHRpb25zLl9faTE4bi5wdXNoKCd7XCJlblwiOntcIlRFU1RfTUVTU0FHRVwiOlwiVGVzdCBNZXNzYWdlXCJ9LFwiemgtVFdcIjp7XCJURVNUX01FU1NBR0VcIjpcIua4rOippuioiuaBr1wifX0nKVxuICBkZWxldGUgQ29tcG9uZW50Lm9wdGlvbnMuX0N0b3Jcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///231\n')},417:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredEuclidean", function() { return squaredEuclidean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "euclidean", function() { return euclidean; });\nfunction squaredEuclidean(p, q) {\r\n    let d = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        d += (p[i] - q[i]) * (p[i] - q[i]);\r\n    }\r\n    return d;\r\n}\r\nfunction euclidean(p, q) {\r\n    return Math.sqrt(squaredEuclidean(p, q));\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21sLWRpc3RhbmNlLWV1Y2xpZGVhbi9saWItZXM2L2V1Y2xpZGVhbi5qcz81OWU3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRXVjbGlkZWFuKHAsIHEpIHtcclxuICAgIGxldCBkID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGQgKz0gKHBbaV0gLSBxW2ldKSAqIChwW2ldIC0gcVtpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXVjbGlkZWFuKHAsIHEpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlZEV1Y2xpZGVhbihwLCBxKSk7XHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///417\n')},546:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_1295245c_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(230);\n/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_1295245c_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_1295245c_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_KNearestNeighbors_less_vue_type_style_index_0_id_1295245c_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/Mzc0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTMhLi9LTmVhcmVzdE5laWdoYm9ycy5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTI5NTI0NWMmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTMhLi9LTmVhcmVzdE5laWdoYm9ycy5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTI5NTI0NWMmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///546\n")},547:function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)(true);\n// Module\nexports.push([module.i, "", "",{"version":3,"sources":[],"names":[],"mappings":"","file":"KNearestNeighbors.less?vue&type=style&index=0&id=1295245c&lang=less&scoped=true&"}]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmxlc3M/YjkwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKSh0cnVlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W10sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIlwiLFwiZmlsZVwiOlwiS05lYXJlc3ROZWlnaGJvcnMubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTEyOTUyNDVjJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIn1dKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///547\n')},548:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);\n/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__);\n /* harmony default export */ __webpack_exports__["default"] = (_node_modules_kazupon_vue_i18n_loader_lib_index_js_KNearestNeighbors_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLnlhbWw/NjA4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2F6dXBvbi92dWUtaTE4bi1sb2FkZXIvbGliL2luZGV4LmpzIS4vS05lYXJlc3ROZWlnaGJvcnMueWFtbD92dWUmdHlwZT1jdXN0b20maW5kZXg9MCZibG9ja1R5cGU9aTE4biZpc3N1ZXJQYXRoPSUyRmFwcCUyRnNyYyUyRmNvbXBvbmVudHMlMkZDb25maWd1cmF0aW9uUGFuZWwlMkZLTmVhcmVzdE5laWdoYm9ycyUyRktOZWFyZXN0TmVpZ2hib3JzLnZ1ZSZsYW5nPXlhbWxcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGthenVwb24vdnVlLWkxOG4tbG9hZGVyL2xpYi9pbmRleC5qcyEuL0tOZWFyZXN0TmVpZ2hib3JzLnlhbWw/dnVlJnR5cGU9Y3VzdG9tJmluZGV4PTAmYmxvY2tUeXBlPWkxOG4maXNzdWVyUGF0aD0lMkZhcHAlMkZzcmMlMkZjb21wb25lbnRzJTJGQ29uZmlndXJhdGlvblBhbmVsJTJGS05lYXJlc3ROZWlnaGJvcnMlMkZLTmVhcmVzdE5laWdoYm9ycy52dWUmbGFuZz15YW1sXCIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///548\n')},576:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.html?vue&type=template&id=1295245c&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c("div", { staticClass: "DecisionTree" }, [\n    _c("div", { staticClass: "field" }, [\n      _c("label", { attrs: { for: "KNearestNeighborsOptionsK" } }, [\n        _vm._v(_vm._s(_vm.$t("K-nearest neighbor")))\n      ]),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.KNearestNeighborsOptionsK,\n            expression: "localConfig.KNearestNeighborsOptionsK"\n          }\n        ],\n        attrs: { type: "number", min: "2", id: "KNearestNeighborsOptionsK" },\n        domProps: { value: _vm.localConfig.KNearestNeighborsOptionsK },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig,\n              "KNearestNeighborsOptionsK",\n              $event.target.value\n            )\n          }\n        }\n      })\n    ]),\n    _vm._v(" "),\n    !_vm.isModelBuilded\n      ? _c("div", { staticClass: "ui field" }, [\n          _c(\n            "button",\n            {\n              staticClass: "ui primary fluid button",\n              attrs: { type: "button" },\n              on: { click: _vm.start }\n            },\n            [\n              [\n                _vm._v(\n                  "\\r\\n        " +\n                    _vm._s(_vm.$t("Build Model and Predict")) +\n                    "\\r\\n      "\n                )\n              ]\n            ],\n            2\n          )\n        ])\n      : _vm._e(),\n    _vm._v(" "),\n    _vm.isModelBuilded && !_vm.isModelUnsupervised\n      ? _c("div", { staticClass: "ui field" }, [\n          _c(\n            "button",\n            {\n              staticClass: "ui primary fluid button",\n              class: { disabled: !_vm.$parent.isNeedPredict },\n              attrs: { type: "button" },\n              on: { click: _vm.start }\n            },\n            [\n              [\n                _vm._v(\n                  "\\r\\n        " + _vm._s(_vm.$t("Predict")) + "\\r\\n      "\n                )\n              ]\n            ],\n            2\n          )\n        ])\n      : _vm._e(),\n    _vm._v(" "),\n    _vm.isModelBuilded\n      ? _c("div", { staticClass: "ui field" }, [\n          _c(\n            "button",\n            {\n              staticClass: "ui primary fluid button",\n              attrs: { type: "button" },\n              on: { click: _vm.showModel }\n            },\n            [_vm._v("\\r\\n      " + _vm._s(_vm.$t("Show Model")) + "\\r\\n    ")]\n          )\n        ])\n      : _vm._e()\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.html?vue&type=template&id=1295245c&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js\nvar helpers_typeof = __webpack_require__(1);\nvar typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(0);\nvar asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);\n\n// EXTERNAL MODULE: ./node_modules/ml-distance-euclidean/lib-es6/euclidean.js\nvar euclidean = __webpack_require__(417);\n\n// CONCATENATED MODULE: ./node_modules/ml-knn/src/KDTree.js\n/*\n * Original code from:\n *\n * k-d Tree JavaScript - V 1.01\n *\n * https://github.com/ubilabs/kd-tree-javascript\n *\n * @author Mircea Pricop <pricop@ubilabs.net>, 2012\n * @author Martin Kleppe <kleppe@ubilabs.net>, 2012\n * @author Ubilabs http://ubilabs.net, 2012\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */\n\nfunction Node(obj, dimension, parent) {\n  this.obj = obj;\n  this.left = null;\n  this.right = null;\n  this.parent = parent;\n  this.dimension = dimension;\n}\n\nclass KDTree {\n  constructor(points, metric) {\n    // If points is not an array, assume we\'re loading a pre-built tree\n    if (!Array.isArray(points)) {\n      this.dimensions = points.dimensions;\n      this.root = points;\n      restoreParent(this.root);\n    } else {\n      this.dimensions = new Array(points[0].length);\n      for (var i = 0; i < this.dimensions.length; i++) {\n        this.dimensions[i] = i;\n      }\n      this.root = buildTree(points, 0, null, this.dimensions);\n    }\n    this.metric = metric;\n  }\n\n  // Convert to a JSON serializable structure; this just requires removing\n  // the `parent` property\n  toJSON() {\n    const result = toJSONImpl(this.root, true);\n    result.dimensions = this.dimensions;\n    return result;\n  }\n\n  nearest(point, maxNodes, maxDistance) {\n    const metric = this.metric;\n    const dimensions = this.dimensions;\n    var i;\n\n    const bestNodes = new BinaryHeap(function (e) {\n      return -e[1];\n    });\n\n    function nearestSearch(node) {\n      const dimension = dimensions[node.dimension];\n      const ownDistance = metric(point, node.obj);\n      const linearPoint = {};\n      var bestChild, linearDistance, otherChild, i;\n\n      function saveNode(node, distance) {\n        bestNodes.push([node, distance]);\n        if (bestNodes.size() > maxNodes) {\n          bestNodes.pop();\n        }\n      }\n\n      for (i = 0; i < dimensions.length; i += 1) {\n        if (i === node.dimension) {\n          linearPoint[dimensions[i]] = point[dimensions[i]];\n        } else {\n          linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n        }\n      }\n\n      linearDistance = metric(linearPoint, node.obj);\n\n      if (node.right === null && node.left === null) {\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n          saveNode(node, ownDistance);\n        }\n        return;\n      }\n\n      if (node.right === null) {\n        bestChild = node.left;\n      } else if (node.left === null) {\n        bestChild = node.right;\n      } else {\n        if (point[dimension] < node.obj[dimension]) {\n          bestChild = node.left;\n        } else {\n          bestChild = node.right;\n        }\n      }\n\n      nearestSearch(bestChild);\n\n      if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n        saveNode(node, ownDistance);\n      }\n\n      if (\n        bestNodes.size() < maxNodes ||\n        Math.abs(linearDistance) < bestNodes.peek()[1]\n      ) {\n        if (bestChild === node.left) {\n          otherChild = node.right;\n        } else {\n          otherChild = node.left;\n        }\n        if (otherChild !== null) {\n          nearestSearch(otherChild);\n        }\n      }\n    }\n\n    if (maxDistance) {\n      for (i = 0; i < maxNodes; i += 1) {\n        bestNodes.push([null, maxDistance]);\n      }\n    }\n\n    if (this.root) {\n      nearestSearch(this.root);\n    }\n\n    const result = [];\n    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\n      if (bestNodes.content[i][0]) {\n        result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\n      }\n    }\n    return result;\n  }\n}\n\nfunction toJSONImpl(src) {\n  const dest = new Node(src.obj, src.dimension, null);\n  if (src.left) dest.left = toJSONImpl(src.left);\n  if (src.right) dest.right = toJSONImpl(src.right);\n  return dest;\n}\n\nfunction buildTree(points, depth, parent, dimensions) {\n  const dim = depth % dimensions.length;\n\n  if (points.length === 0) {\n    return null;\n  }\n  if (points.length === 1) {\n    return new Node(points[0], dim, parent);\n  }\n\n  points.sort((a, b) => a[dimensions[dim]] - b[dimensions[dim]]);\n\n  const median = Math.floor(points.length / 2);\n  const node = new Node(points[median], dim, parent);\n  node.left = buildTree(points.slice(0, median), depth + 1, node, dimensions);\n  node.right = buildTree(points.slice(median + 1), depth + 1, node, dimensions);\n\n  return node;\n}\n\nfunction restoreParent(root) {\n  if (root.left) {\n    root.left.parent = root;\n    restoreParent(root.left);\n  }\n\n  if (root.right) {\n    root.right.parent = root;\n    restoreParent(root.right);\n  }\n}\n\n// Binary heap implementation from:\n// http://eloquentjavascript.net/appendix2.html\nclass BinaryHeap {\n  constructor(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  }\n\n  peek() {\n    return this.content[0];\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n];\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element\'s index, and fetch it.\n      const parentN = Math.floor((n + 1) / 2) - 1;\n      const parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update \'n\' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to move it further.\n        break;\n      }\n    }\n  }\n\n  sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        var child1Score = this.scoreFunction(child1);\n        // If the score is less than our element\'s, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } else {\n        // Otherwise, we are done.\n        break;\n      }\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/ml-knn/src/index.js\n\n\n\n\nclass src_KNN {\n  /**\n   * @param {Array} dataset\n   * @param {Array} labels\n   * @param {object} options\n   * @param {number} [options.k=numberOfClasses + 1] - Number of neighbors to classify.\n   * @param {function} [options.distance=euclideanDistance] - Distance function that takes two parameters.\n   */\n  constructor(dataset, labels, options = {}) {\n    if (dataset === true) {\n      const model = labels;\n      this.kdTree = new KDTree(model.kdTree, options);\n      this.k = model.k;\n      this.classes = new Set(model.classes);\n      this.isEuclidean = model.isEuclidean;\n      return;\n    }\n\n    const classes = new Set(labels);\n\n    const { distance = euclidean["euclidean"], k = classes.size + 1 } = options;\n\n    const points = new Array(dataset.length);\n    for (var i = 0; i < points.length; ++i) {\n      points[i] = dataset[i].slice();\n    }\n\n    for (i = 0; i < labels.length; ++i) {\n      points[i].push(labels[i]);\n    }\n\n    this.kdTree = new KDTree(points, distance);\n    this.k = k;\n    this.classes = classes;\n    this.isEuclidean = distance === euclidean["euclidean"];\n  }\n\n  /**\n   * Create a new KNN instance with the given model.\n   * @param {object} model\n   * @param {function} distance=euclideanDistance - distance function must be provided if the model wasn\'t trained with euclidean distance.\n   * @return {KNN}\n   */\n  static load(model, distance = euclidean["euclidean"]) {\n    if (model.name !== \'KNN\') {\n      throw new Error(`invalid model: ${model.name}`);\n    }\n    if (!model.isEuclidean && distance === euclidean["euclidean"]) {\n      throw new Error(\n        \'a custom distance function was used to create the model. Please provide it again\'\n      );\n    }\n    if (model.isEuclidean && distance !== euclidean["euclidean"]) {\n      throw new Error(\n        \'the model was created with the default distance function. Do not load it with another one\'\n      );\n    }\n    return new src_KNN(true, model, distance);\n  }\n\n  /**\n   * Return a JSON containing the kd-tree model.\n   * @return {object} JSON KNN model.\n   */\n  toJSON() {\n    return {\n      name: \'KNN\',\n      kdTree: this.kdTree,\n      k: this.k,\n      classes: Array.from(this.classes),\n      isEuclidean: this.isEuclidean\n    };\n  }\n\n  /**\n   * Predicts the output given the matrix to predict.\n   * @param {Array} dataset\n   * @return {Array} predictions\n   */\n  predict(dataset) {\n    if (Array.isArray(dataset)) {\n      if (typeof dataset[0] === \'number\') {\n        return getSinglePrediction(this, dataset);\n      } else if (\n        Array.isArray(dataset[0]) &&\n        typeof dataset[0][0] === \'number\'\n      ) {\n        const predictions = new Array(dataset.length);\n        for (var i = 0; i < dataset.length; i++) {\n          predictions[i] = getSinglePrediction(this, dataset[i]);\n        }\n        return predictions;\n      }\n    }\n    throw new TypeError(\'dataset to predict must be an array or a matrix\');\n  }\n}\n\nfunction getSinglePrediction(knn, currentCase) {\n  var nearestPoints = knn.kdTree.nearest(currentCase, knn.k);\n  var pointsPerClass = {};\n  var predictedClass = -1;\n  var maxPoints = -1;\n  var lastElement = nearestPoints[0][0].length - 1;\n\n  for (var element of knn.classes) {\n    pointsPerClass[element] = 0;\n  }\n\n  for (var i = 0; i < nearestPoints.length; ++i) {\n    var currentClass = nearestPoints[i][0][lastElement];\n    var currentPoints = ++pointsPerClass[currentClass];\n    if (currentPoints > maxPoints) {\n      predictedClass = currentClass;\n      maxPoints = currentPoints;\n    }\n  }\n\n  return predictedClass;\n}\n\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighborsMethodsBuild.js\n\n\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof_default()(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n/* harmony default export */ var KNearestNeighborsMethodsBuild = (function (KNearestNeighbors) {\n  KNearestNeighbors.methods.startPredict = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return this.start();\n        case 2:\n          return _context.abrupt("return", _context.sent);\n        case 3:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee, this);\n  }));\n  KNearestNeighbors.methods.start = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var _this = this;\n    var data, predictVector, predictResults, testSetRowIndexes, predictVectorToEvalute;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          //this.localConfig.modelJSON = null\n          this.config.loadingProgress = 0;\n          // console.log(\'start\', 1)\n\n          this.localConfig.modelJSON = null;\n          this.localConfig.modelEvaluations = [];\n          _context2.next = 5;\n          return this.$parent.getVectorData();\n        case 5:\n          data = _context2.sent;\n          this.dataToShow = data;\n          if (data.trainSetClasses.length === 0) {\n            console.error(\'No trainSetClasses\');\n            //throw Error(\'No trainSetClasses\')\n          }\n\n          // console.log(data)\n          //return false\n          this.config.loadingProgress = 0.25;\n\n          // console.log(\'start\', 2)\n          //console.log(data.trainSet[0])\n\n          // console.log(\'start\', 3)\n          if (!(data.trainSetClasses.length > 0)) {\n            _context2.next = 28;\n            break;\n          }\n          if (!this.localConfig.modelJSON) {\n            this.model = this.buildModel(data);\n            this.localConfig.modelJSON = this.model;\n          } else {\n            this.model = src_KNN.load(this.localConfig.modelJSON);\n          }\n\n          //console.log(this.model.toJSON())\n\n          //console.log(this.model)\n          // console.log(\'start\', 5)\n\n          this.config.loadingProgress = 0.5;\n\n          // console.log(\'start\', 9)\n          //console.log(data.testSet)\n          _context2.next = 14;\n          return this.getPredictResultsVector(this.model, data);\n        case 14:\n          predictVector = _context2.sent;\n          _context2.next = 17;\n          return this.getPredictResultsValue(data, predictVector);\n        case 17:\n          predictResults = _context2.sent;\n          if (!(predictResults[0] === \'undefined\')) {\n            _context2.next = 22;\n            break;\n          }\n          this.config.loadingProgress = 1;\n          console.error(\'predict is undefined\');\n          return _context2.abrupt("return", false);\n        case 22:\n          // console.log(\'start\', 10)\n          this.config.loadingProgress = 0.75;\n          if (this.$parent.hasModelEvaluated === false) {\n            testSetRowIndexes = data.testSetRowIndexes;\n            this.unknownsPrediction = [];\n            predictVectorToEvalute = predictVector.filter(function (value, i) {\n              var notMatch = testSetRowIndexes.indexOf(i) === -1;\n              if (notMatch === false) {\n                _this.unknownsPrediction.push(value);\n              }\n              return notMatch;\n            });\n            this.evaluationResults(data.trainSetClasses, predictVectorToEvalute);\n          }\n\n          //console.log(predictResults)\n          this.$parent.setPredictResults(predictResults);\n          this.config.loadingProgress = 0.9;\n          _context2.next = 29;\n          break;\n        case 28:\n          this.model = \'unsupervised\';\n        case 29:\n          if (this.$parent.isModelWindowOpened) {\n            this.showModel();\n          }\n          this.config.loadingProgress = 1;\n          this.config.modelBuildedTime = new Date().getTime();\n        case 32:\n        case "end":\n          return _context2.stop();\n      }\n    }, _callee2, this);\n  }));\n  KNearestNeighbors.methods.buildModel = function (data) {\n    var testSetRowIndexes = data.testSetRowIndexes,\n      trainSetRowIndexes = data.trainSetRowIndexes;\n    // console.log(testSetRowIndexes, trainSetRowIndexes)\n    var dataset = data.testSet.filter(function (row, i) {\n      return testSetRowIndexes.indexOf(i) === -1;\n    });\n    // let dataset = data.trainSet\n\n    // console.log(dataset)\n    var predictions = data.trainSetClasses;\n    // console.log(predictions)\n\n    if (dataset.length === 0) {\n      dataset = data.testSet;\n      predictions = dataset.map(function (item) {\n        return \'unknown\';\n      });\n    }\n    if (dataset.length !== predictions.length) {\n      console.error(\'length is not match\');\n    }\n    // console.log(\'ok\')\n    return new src_KNN(dataset, predictions, {\n      k: this.localConfig.KNearestNeighborsOptionsK\n    });\n  };\n  KNearestNeighbors.methods.getPredictResultsVector = /*#__PURE__*/function () {\n    var _ref3 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(model, data) {\n      var testSet, resultVector;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            testSet = data.testSet;\n            resultVector = model.predict(testSet);\n            return _context3.abrupt("return", resultVector);\n          case 3:\n          case "end":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n    return function (_x, _x2) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  KNearestNeighbors.methods.getPredictResultsValue = /*#__PURE__*/function () {\n    var _ref4 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data, resultVector) {\n      var trainSetClassesDict;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            trainSetClassesDict = data.trainSetClassesDict; //console.log(trainSetClassesDict)\n            return _context4.abrupt("return", resultVector.map(function (index) {\n              return trainSetClassesDict[index];\n            }));\n          case 2:\n          case "end":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    return function (_x3, _x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  KNearestNeighbors.methods.evaluationResults = /*#__PURE__*/function () {\n    var _ref5 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(train, predict) {\n      var accuracy, accuracyInfo;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            this.$parent.resetModelEvaluation();\n            // console.log(train)\n            // console.log(predict)\n            //console.log(data.trainSetClasses.length, getTrainSetPredicts.length, data.testSetRowIndexes.length)\n            _context5.next = 3;\n            return this.$parent.calcAccuracy(train, predict);\n          case 3:\n            accuracy = _context5.sent;\n            //console.log(accuracy)\n            accuracyInfo = {\n              name: \'accuracy\',\n              type: \'percent\',\n              value: accuracy\n            }; //console.log(accuracyInfo)\n            this.localConfig.modelEvaluations.push(accuracyInfo);\n          case 6:\n          case "end":\n            return _context5.stop();\n        }\n      }, _callee5, this);\n    }));\n    return function (_x5, _x6) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n});\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighborsMethodsShow.js\n\n\nfunction KNearestNeighborsMethodsShow_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ KNearestNeighborsMethodsShow_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof_default()(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n//import {euclidean} from \'ml-distance-euclidean\'\nvar KNearestNeighborsMethodsShow_euclidean = __webpack_require__(417).euclidean;\n//const euclidean = MLDistanceEuclidean.euclidean\n\n/* harmony default export */ var KNearestNeighborsMethodsShow = (function (KNearestNeighbors) {\n  KNearestNeighbors.methods.showModel = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/KNearestNeighborsMethodsShow_regeneratorRuntime().mark(function _callee() {\n    var _this = this;\n    var unknownSetRowIndex, neighbors, neighborsID, unknowns, unknownsID, distanceMatrix, colorMatrix, tableHeaderUnknownColspan, tableHeader, trainSetClassesDict, unknownsPrediction, tableBody, bodyHTML, title, modelWindow;\n    return KNearestNeighborsMethodsShow_regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (this.model) {\n            _context.next = 3;\n            break;\n          }\n          _context.next = 3;\n          return this.start();\n        case 3:\n          // --------------------------\n          //console.log(this.dataToShow)\n          unknownSetRowIndex = this.dataToShow.testSetRowIndexes;\n          neighbors = [];\n          neighborsID = [];\n          unknowns = [];\n          unknownsID = []; //console.log(unknownSetRowIndex)\n          this.dataToShow.testSet.forEach(function (set, i) {\n            if (unknownSetRowIndex.indexOf(i) === -1) {\n              neighbors.push(set);\n              neighborsID.push(i);\n            } else {\n              unknowns.push(set);\n              unknownsID.push(i);\n            }\n          });\n          if (unknowns.length === 0) {\n            unknowns = [].concat(neighbors);\n            unknownsID = [].concat(neighborsID);\n            unknownSetRowIndex = [].concat(neighborsID);\n          }\n\n          //console.log(neighbors)\n          // console.log(unknowns)\n          if (neighbors.length === 0) {\n            neighbors = unknowns;\n            neighborsID = unknownsID;\n          }\n\n          // --------------------------\n          distanceMatrix = unknowns.map(function (unknownFeature) {\n            var maxDistance = null;\n            var distances = neighbors.map(function (neighbor) {\n              var distance = KNearestNeighborsMethodsShow_euclidean(unknownFeature, neighbor);\n              if (maxDistance === null || distance > maxDistance) {\n                maxDistance = distance;\n              }\n              return distance;\n            });\n            distances = distances.map(function (d) {\n              return (maxDistance - d) / maxDistance;\n            });\n            return distances;\n          }); // console.log(distanceMatrix)\n          // console.log(distanceMatrix)\n          if (!(distanceMatrix.length === 0)) {\n            _context.next = 14;\n            break;\n          }\n          throw Error(\'Distance matrix is empty\');\n        case 14:\n          colorMatrix = distanceMatrix.map(function (unknown) {\n            return unknown.map(function (d) {\n              return heatMapColorforValue(d);\n            });\n          }); //console.log(colorMatrix)\n          // --------------------------\n          tableHeaderUnknownColspan = 2;\n          if (this.model === \'unsupervised\') {\n            tableHeaderUnknownColspan = 1;\n          }\n\n          // console.log({tableHeaderUnknownColspan, colorMatrix})\n          tableHeader = "<thead>\\n  <tr>\\n    <th rowspan=\\"2\\" colspan=\\"".concat(tableHeaderUnknownColspan, "\\" valign=\\"bottom\\">").concat(this.$t(\'Unknowns\'), "</th>\\n    <th colspan=\\"").concat(colorMatrix[0].length, "\\">").concat(this.$t(\'Neighbors\'), "</th>\\n  </tr>\\n  <tr>").concat(colorMatrix[0].map(function (value, i) {\n            return "<th>".concat(neighborsID[i] + 1, "</th>");\n          }).join(\'\'), "</tr>\\n</thead>");\n          trainSetClassesDict = this.dataToShow.trainSetClassesDict;\n          unknownsPrediction = this.unknownsPrediction; // console.log({trainSetClassesDict, unknownsPrediction})\n          if (!(unknownsPrediction.length === 0)) {\n            _context.next = 26;\n            break;\n          }\n          _context.next = 23;\n          return this.$parent.getTrainSetPredictsResult();\n        case 23:\n          unknownsPrediction = _context.sent;\n          _context.next = 27;\n          break;\n        case 26:\n          unknownsPrediction = unknownsPrediction.map(function (i) {\n            return trainSetClassesDict[i];\n          });\n        case 27:\n          tableBody = "<tbody>\\n".concat(colorMatrix.map(function (row, i) {\n            var thPrediection = "<th>".concat(unknownsPrediction[i], "</th>");\n            if (_this.model === \'unsupervised\') {\n              thPrediection = \'\';\n            }\n            return "<tr>\\n  <th>".concat(unknownSetRowIndex[i] + 1, "</th>\\n  ").concat(thPrediection, "\\n  ").concat(row.map(function (color, j) {\n              var d = distanceMatrix[i][j];\n              var dText = d;\n              dText = Math.round(dText * 100) + \'%\';\n              if (d > 0.7 || d < 0.3) {\n                return "<td style=\\"text-align:center;background-color: ".concat(color, "; color: white\\">").concat(dText, "</td>");\n              } else {\n                return "<td style=\\"text-align:center;background-color: ".concat(color, "\\">").concat(dText, "</td>");\n              }\n            }).join(\'\'), "\\n</tr>");\n          }).join(\'\\n\'), "\\n</tbody>"); // --------------------------\n          // console.log(tableBody)\n          bodyHTML = "<table border=\\"1\\" align=\\"center\\">\\n    ".concat(tableHeader, "\\n    ").concat(tableBody, "\\n</table>");\n          bodyHTML = "<div class=\\"tree\\">".concat(bodyHTML, "</div>");\n          //console.error(\'[TODO]\')\n          //console.log()\n          title = this.$t(\'KNN\') + " (" + new Date().mmddhhmm() + \')\'; // console.log(\'KNNModelShow\' + this.config.modelBuildedTime)\n          modelWindow = this.utils.PopupUtils.open({\n            windowName: \'KNNModelShow\' + this.config.modelBuildedTime,\n            cssURL: this.modelCSSURL,\n            bodyHTML: bodyHTML,\n            size: \'right\',\n            //size: \'left\',\n            title: title\n          });\n          modelWindow.scrollToTop();\n          modelWindow.scrollToCenter();\n        case 34:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee, this);\n  }));\n\n  /**\n   * https://stackoverflow.com/a/27263918/6645399\n   */\n  function heatMapColorforValue(value) {\n    var h = (1.0 - value) * 240;\n    return "hsl(" + h + ", 100%, 50%)";\n    //return `rgba(22, 160, 133, ${value})`\n    // rgb(22, 160, 133)\n  }\n});\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighborsMethodsTest.js\n\n\nfunction KNearestNeighborsMethodsTest_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ KNearestNeighborsMethodsTest_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof_default()(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n// https://www.npmjs.com/package/ml-knn\n\n/* harmony default export */ var KNearestNeighborsMethodsTest = (function (KNearestNeighbors) {\n  KNearestNeighbors.methods.testKNN = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/KNearestNeighborsMethodsTest_regeneratorRuntime().mark(function _callee() {\n    var dataset, predictions, knn, ans;\n    return KNearestNeighborsMethodsTest_regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          dataset = [[0, 0, 0], [0, 1, 1], [1, 1, 0], [2, 2, 2], [1, 2, 2], [2, 1, 2]];\n          predictions = [0, 0, 0, 1, 1, 1];\n          knn = new src_KNN(dataset, predictions);\n          dataset = [[0, 0, 0], [2, 2, 2]];\n          ans = knn.predict(dataset);\n          console.log(ans);\n        case 6:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n});\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--6!./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.js?vue&type=script&lang=js&\nvar KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors = {\n  props: [\'config\', \'localConfig\', \'utils\'],\n  data: function data() {\n    this.$i18n.locale = this.localConfig.locale;\n    return {\n      model: null,\n      dataToShow: null,\n      unknownsPrediction: []\n    };\n  },\n  watch: {\n    \'localConfig.locale\': function localConfigLocale() {\n      this.$i18n.locale = this.localConfig.locale;\n    },\n    \'localConfig.KNearestNeighborsOptionsK\': function localConfigKNearestNeighborsOptionsK() {\n      this.$parent.clearPrediction();\n    }\n  },\n  computed: {\n    isModelBuilded: function isModelBuilded() {\n      return this.model !== null;\n    },\n    isModelUnsupervised: function isModelUnsupervised() {\n      return this.model !== null && this.model === \'unsupervised\';\n    }\n  },\n  mounted: function mounted() {\n    //    setTimeout(() => {\n    //      this.start()\n    //    }, 1000)\n\n    //this.testKNN()\n  },\n  methods: {}\n};\n\nKNearestNeighborsMethodsBuild(KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n\nKNearestNeighborsMethodsShow(KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n\nKNearestNeighborsMethodsTest(KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n/* harmony default export */ var KNearestNeighborsvue_type_script_lang_js_ = (KNearestNeighborsvue_type_script_lang_js_KNearestNeighbors);\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.js?vue&type=script&lang=js&\n /* harmony default export */ var KNearestNeighbors_KNearestNeighborsvue_type_script_lang_js_ = (KNearestNeighborsvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.less?vue&type=style&index=0&id=1295245c&lang=less&scoped=true&\nvar KNearestNeighborsvue_type_style_index_0_id_1295245c_lang_less_scoped_true_ = __webpack_require__(546);\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FConfigurationPanel%2FKNearestNeighbors%2FKNearestNeighbors.vue&lang=yaml\nvar KNearestNeighborsvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml = __webpack_require__(548);\n\n// CONCATENATED MODULE: ./src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  KNearestNeighbors_KNearestNeighborsvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "1295245c",\n  null\n  \n)\n\n/* custom blocks */\n\nif (typeof KNearestNeighborsvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml["default"] === \'function\') Object(KNearestNeighborsvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FConfigurationPanel_2FKNearestNeighbors_2FKNearestNeighbors_vue_lang_yaml["default"])(component)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "src/components/ConfigurationPanel/KNearestNeighbors/KNearestNeighbors.vue"\n/* harmony default export */ var KNearestNeighbors_KNearestNeighbors = __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzLmh0bWw/NzQ4OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwta25uL3NyYy9LRFRyZWUuanM/OWQwYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWwta25uL3NyYy9pbmRleC5qcz8yNjEyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NvbmZpZ3VyYXRpb25QYW5lbC9LTmVhcmVzdE5laWdoYm9ycy9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNCdWlsZC5qcz8zMWM0Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NvbmZpZ3VyYXRpb25QYW5lbC9LTmVhcmVzdE5laWdoYm9ycy9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNTaG93LmpzPzNkYjciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29uZmlndXJhdGlvblBhbmVsL0tOZWFyZXN0TmVpZ2hib3JzL0tOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Rlc3QuanM/NTU0NiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMuanM/ZmFiMiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMuanM/ZjAxNiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMudnVlP2RkODMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIkRlY2lzaW9uVHJlZVwiIH0sIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgX2MoXCJsYWJlbFwiLCB7IGF0dHJzOiB7IGZvcjogXCJLTmVhcmVzdE5laWdoYm9yc09wdGlvbnNLXCIgfSB9LCBbXG4gICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLiR0KFwiSy1uZWFyZXN0IG5laWdoYm9yXCIpKSlcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLmxvY2FsQ29uZmlnLktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0ssXG4gICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLktOZWFyZXN0TmVpZ2hib3JzT3B0aW9uc0tcIlxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJudW1iZXJcIiwgbWluOiBcIjJcIiwgaWQ6IFwiS05lYXJlc3ROZWlnaGJvcnNPcHRpb25zS1wiIH0sXG4gICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubG9jYWxDb25maWcuS05lYXJlc3ROZWlnaGJvcnNPcHRpb25zSyB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF92bS4kc2V0KFxuICAgICAgICAgICAgICBfdm0ubG9jYWxDb25maWcsXG4gICAgICAgICAgICAgIFwiS05lYXJlc3ROZWlnaGJvcnNPcHRpb25zS1wiLFxuICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF0pLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgIV92bS5pc01vZGVsQnVpbGRlZFxuICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInVpIGZpZWxkXCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidWkgcHJpbWFyeSBmbHVpZCBidXR0b25cIixcbiAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnN0YXJ0IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIlxcclxcbiAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLiR0KFwiQnVpbGQgTW9kZWwgYW5kIFByZWRpY3RcIikpICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG4gICAgICBcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDJcbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICA6IF92bS5fZSgpLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX3ZtLmlzTW9kZWxCdWlsZGVkICYmICFfdm0uaXNNb2RlbFVuc3VwZXJ2aXNlZFxuICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInVpIGZpZWxkXCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidWkgcHJpbWFyeSBmbHVpZCBidXR0b25cIixcbiAgICAgICAgICAgICAgY2xhc3M6IHsgZGlzYWJsZWQ6ICFfdm0uJHBhcmVudC5pc05lZWRQcmVkaWN0IH0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5zdGFydCB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgXCJcXHJcXG4gICAgICAgIFwiICsgX3ZtLl9zKF92bS4kdChcIlByZWRpY3RcIikpICsgXCJcXHJcXG4gICAgICBcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDJcbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICA6IF92bS5fZSgpLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX3ZtLmlzTW9kZWxCdWlsZGVkXG4gICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidWkgZmllbGRcIiB9LCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ1aSBwcmltYXJ5IGZsdWlkIGJ1dHRvblwiLFxuICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uc2hvd01vZGVsIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLl92KFwiXFxyXFxuICAgICAgXCIgKyBfdm0uX3MoX3ZtLiR0KFwiU2hvdyBNb2RlbFwiKSkgKyBcIlxcclxcbiAgICBcIildXG4gICAgICAgICAgKVxuICAgICAgICBdKVxuICAgICAgOiBfdm0uX2UoKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIi8qXG4gKiBPcmlnaW5hbCBjb2RlIGZyb206XG4gKlxuICogay1kIFRyZWUgSmF2YVNjcmlwdCAtIFYgMS4wMVxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS91YmlsYWJzL2tkLXRyZWUtamF2YXNjcmlwdFxuICpcbiAqIEBhdXRob3IgTWlyY2VhIFByaWNvcCA8cHJpY29wQHViaWxhYnMubmV0PiwgMjAxMlxuICogQGF1dGhvciBNYXJ0aW4gS2xlcHBlIDxrbGVwcGVAdWJpbGFicy5uZXQ+LCAyMDEyXG4gKiBAYXV0aG9yIFViaWxhYnMgaHR0cDovL3ViaWxhYnMubmV0LCAyMDEyXG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSA8aHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHA+XG4gKi9cblxuZnVuY3Rpb24gTm9kZShvYmosIGRpbWVuc2lvbiwgcGFyZW50KSB7XG4gIHRoaXMub2JqID0gb2JqO1xuICB0aGlzLmxlZnQgPSBudWxsO1xuICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLRFRyZWUge1xuICBjb25zdHJ1Y3Rvcihwb2ludHMsIG1ldHJpYykge1xuICAgIC8vIElmIHBvaW50cyBpcyBub3QgYW4gYXJyYXksIGFzc3VtZSB3ZSdyZSBsb2FkaW5nIGEgcHJlLWJ1aWx0IHRyZWVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0gcG9pbnRzLmRpbWVuc2lvbnM7XG4gICAgICB0aGlzLnJvb3QgPSBwb2ludHM7XG4gICAgICByZXN0b3JlUGFyZW50KHRoaXMucm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBBcnJheShwb2ludHNbMF0ubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc1tpXSA9IGk7XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QgPSBidWlsZFRyZWUocG9pbnRzLCAwLCBudWxsLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIH1cbiAgICB0aGlzLm1ldHJpYyA9IG1ldHJpYztcbiAgfVxuXG4gIC8vIENvbnZlcnQgdG8gYSBKU09OIHNlcmlhbGl6YWJsZSBzdHJ1Y3R1cmU7IHRoaXMganVzdCByZXF1aXJlcyByZW1vdmluZ1xuICAvLyB0aGUgYHBhcmVudGAgcHJvcGVydHlcbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRvSlNPTkltcGwodGhpcy5yb290LCB0cnVlKTtcbiAgICByZXN1bHQuZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgbmVhcmVzdChwb2ludCwgbWF4Tm9kZXMsIG1heERpc3RhbmNlKSB7XG4gICAgY29uc3QgbWV0cmljID0gdGhpcy5tZXRyaWM7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICB2YXIgaTtcblxuICAgIGNvbnN0IGJlc3ROb2RlcyA9IG5ldyBCaW5hcnlIZWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gLWVbMV07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBuZWFyZXN0U2VhcmNoKG5vZGUpIHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGRpbWVuc2lvbnNbbm9kZS5kaW1lbnNpb25dO1xuICAgICAgY29uc3Qgb3duRGlzdGFuY2UgPSBtZXRyaWMocG9pbnQsIG5vZGUub2JqKTtcbiAgICAgIGNvbnN0IGxpbmVhclBvaW50ID0ge307XG4gICAgICB2YXIgYmVzdENoaWxkLCBsaW5lYXJEaXN0YW5jZSwgb3RoZXJDaGlsZCwgaTtcblxuICAgICAgZnVuY3Rpb24gc2F2ZU5vZGUobm9kZSwgZGlzdGFuY2UpIHtcbiAgICAgICAgYmVzdE5vZGVzLnB1c2goW25vZGUsIGRpc3RhbmNlXSk7XG4gICAgICAgIGlmIChiZXN0Tm9kZXMuc2l6ZSgpID4gbWF4Tm9kZXMpIHtcbiAgICAgICAgICBiZXN0Tm9kZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPT09IG5vZGUuZGltZW5zaW9uKSB7XG4gICAgICAgICAgbGluZWFyUG9pbnRbZGltZW5zaW9uc1tpXV0gPSBwb2ludFtkaW1lbnNpb25zW2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lYXJQb2ludFtkaW1lbnNpb25zW2ldXSA9IG5vZGUub2JqW2RpbWVuc2lvbnNbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbmVhckRpc3RhbmNlID0gbWV0cmljKGxpbmVhclBvaW50LCBub2RlLm9iaik7XG5cbiAgICAgIGlmIChub2RlLnJpZ2h0ID09PSBudWxsICYmIG5vZGUubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoYmVzdE5vZGVzLnNpemUoKSA8IG1heE5vZGVzIHx8IG93bkRpc3RhbmNlIDwgYmVzdE5vZGVzLnBlZWsoKVsxXSkge1xuICAgICAgICAgIHNhdmVOb2RlKG5vZGUsIG93bkRpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgIGJlc3RDaGlsZCA9IG5vZGUubGVmdDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIGJlc3RDaGlsZCA9IG5vZGUucmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocG9pbnRbZGltZW5zaW9uXSA8IG5vZGUub2JqW2RpbWVuc2lvbl0pIHtcbiAgICAgICAgICBiZXN0Q2hpbGQgPSBub2RlLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmVzdENoaWxkID0gbm9kZS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZWFyZXN0U2VhcmNoKGJlc3RDaGlsZCk7XG5cbiAgICAgIGlmIChiZXN0Tm9kZXMuc2l6ZSgpIDwgbWF4Tm9kZXMgfHwgb3duRGlzdGFuY2UgPCBiZXN0Tm9kZXMucGVlaygpWzFdKSB7XG4gICAgICAgIHNhdmVOb2RlKG5vZGUsIG93bkRpc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBiZXN0Tm9kZXMuc2l6ZSgpIDwgbWF4Tm9kZXMgfHxcbiAgICAgICAgTWF0aC5hYnMobGluZWFyRGlzdGFuY2UpIDwgYmVzdE5vZGVzLnBlZWsoKVsxXVxuICAgICAgKSB7XG4gICAgICAgIGlmIChiZXN0Q2hpbGQgPT09IG5vZGUubGVmdCkge1xuICAgICAgICAgIG90aGVyQ2hpbGQgPSBub2RlLnJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyQ2hpbGQgPSBub2RlLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBuZWFyZXN0U2VhcmNoKG90aGVyQ2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heERpc3RhbmNlKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWF4Tm9kZXM7IGkgKz0gMSkge1xuICAgICAgICBiZXN0Tm9kZXMucHVzaChbbnVsbCwgbWF4RGlzdGFuY2VdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICBuZWFyZXN0U2VhcmNoKHRoaXMucm9vdCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IE1hdGgubWluKG1heE5vZGVzLCBiZXN0Tm9kZXMuY29udGVudC5sZW5ndGgpOyBpICs9IDEpIHtcbiAgICAgIGlmIChiZXN0Tm9kZXMuY29udGVudFtpXVswXSkge1xuICAgICAgICByZXN1bHQucHVzaChbYmVzdE5vZGVzLmNvbnRlbnRbaV1bMF0ub2JqLCBiZXN0Tm9kZXMuY29udGVudFtpXVsxXV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvSlNPTkltcGwoc3JjKSB7XG4gIGNvbnN0IGRlc3QgPSBuZXcgTm9kZShzcmMub2JqLCBzcmMuZGltZW5zaW9uLCBudWxsKTtcbiAgaWYgKHNyYy5sZWZ0KSBkZXN0LmxlZnQgPSB0b0pTT05JbXBsKHNyYy5sZWZ0KTtcbiAgaWYgKHNyYy5yaWdodCkgZGVzdC5yaWdodCA9IHRvSlNPTkltcGwoc3JjLnJpZ2h0KTtcbiAgcmV0dXJuIGRlc3Q7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShwb2ludHMsIGRlcHRoLCBwYXJlbnQsIGRpbWVuc2lvbnMpIHtcbiAgY29uc3QgZGltID0gZGVwdGggJSBkaW1lbnNpb25zLmxlbmd0aDtcblxuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHBvaW50c1swXSwgZGltLCBwYXJlbnQpO1xuICB9XG5cbiAgcG9pbnRzLnNvcnQoKGEsIGIpID0+IGFbZGltZW5zaW9uc1tkaW1dXSAtIGJbZGltZW5zaW9uc1tkaW1dXSk7XG5cbiAgY29uc3QgbWVkaWFuID0gTWF0aC5mbG9vcihwb2ludHMubGVuZ3RoIC8gMik7XG4gIGNvbnN0IG5vZGUgPSBuZXcgTm9kZShwb2ludHNbbWVkaWFuXSwgZGltLCBwYXJlbnQpO1xuICBub2RlLmxlZnQgPSBidWlsZFRyZWUocG9pbnRzLnNsaWNlKDAsIG1lZGlhbiksIGRlcHRoICsgMSwgbm9kZSwgZGltZW5zaW9ucyk7XG4gIG5vZGUucmlnaHQgPSBidWlsZFRyZWUocG9pbnRzLnNsaWNlKG1lZGlhbiArIDEpLCBkZXB0aCArIDEsIG5vZGUsIGRpbWVuc2lvbnMpO1xuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlUGFyZW50KHJvb3QpIHtcbiAgaWYgKHJvb3QubGVmdCkge1xuICAgIHJvb3QubGVmdC5wYXJlbnQgPSByb290O1xuICAgIHJlc3RvcmVQYXJlbnQocm9vdC5sZWZ0KTtcbiAgfVxuXG4gIGlmIChyb290LnJpZ2h0KSB7XG4gICAgcm9vdC5yaWdodC5wYXJlbnQgPSByb290O1xuICAgIHJlc3RvcmVQYXJlbnQocm9vdC5yaWdodCk7XG4gIH1cbn1cblxuLy8gQmluYXJ5IGhlYXAgaW1wbGVtZW50YXRpb24gZnJvbTpcbi8vIGh0dHA6Ly9lbG9xdWVudGphdmFzY3JpcHQubmV0L2FwcGVuZGl4Mi5odG1sXG5jbGFzcyBCaW5hcnlIZWFwIHtcbiAgY29uc3RydWN0b3Ioc2NvcmVGdW5jdGlvbikge1xuICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgIHRoaXMuc2NvcmVGdW5jdGlvbiA9IHNjb3JlRnVuY3Rpb247XG4gIH1cblxuICBwdXNoKGVsZW1lbnQpIHtcbiAgICAvLyBBZGQgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHRoaXMuY29udGVudC5wdXNoKGVsZW1lbnQpO1xuICAgIC8vIEFsbG93IGl0IHRvIGJ1YmJsZSB1cC5cbiAgICB0aGlzLmJ1YmJsZVVwKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHBvcCgpIHtcbiAgICAvLyBTdG9yZSB0aGUgZmlyc3QgZWxlbWVudCBzbyB3ZSBjYW4gcmV0dXJuIGl0IGxhdGVyLlxuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XG4gICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxuICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IHNpbmsgZG93bi5cbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29udGVudFswXSA9IGVuZDtcbiAgICAgIHRoaXMuc2lua0Rvd24oMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbMF07XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICB9XG5cbiAgYnViYmxlVXAobikge1xuICAgIC8vIEZldGNoIHRoZSBlbGVtZW50IHRoYXQgaGFzIHRvIGJlIG1vdmVkLlxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dO1xuICAgIC8vIFdoZW4gYXQgMCwgYW4gZWxlbWVudCBjYW4gbm90IGdvIHVwIGFueSBmdXJ0aGVyLlxuICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgY29uc3QgcGFyZW50TiA9IE1hdGguZmxvb3IoKG4gKyAxKSAvIDIpIC0gMTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuY29udGVudFtwYXJlbnROXTtcbiAgICAgIC8vIFN3YXAgdGhlIGVsZW1lbnRzIGlmIHRoZSBwYXJlbnQgaXMgZ3JlYXRlci5cbiAgICAgIGlmICh0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkge1xuICAgICAgICB0aGlzLmNvbnRlbnRbcGFyZW50Tl0gPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XG4gICAgICAgIC8vIFVwZGF0ZSAnbicgdG8gY29udGludWUgYXQgdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgbiA9IHBhcmVudE47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3VuZCBhIHBhcmVudCB0aGF0IGlzIGxlc3MsIG5vIG5lZWQgdG8gbW92ZSBpdCBmdXJ0aGVyLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzaW5rRG93bihuKSB7XG4gICAgLy8gTG9vayB1cCB0aGUgdGFyZ2V0IGVsZW1lbnQgYW5kIGl0cyBzY29yZS5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXTtcbiAgICB2YXIgZWxlbVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIGluZGljZXMgb2YgdGhlIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpICogMjtcbiAgICAgIHZhciBjaGlsZDFOID0gY2hpbGQyTiAtIDE7XG4gICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCxcbiAgICAgIC8vIGlmIGFueS5cbiAgICAgIHZhciBzd2FwID0gbnVsbDtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXG4gICAgICBpZiAoY2hpbGQxTiA8IGxlbmd0aCkge1xuICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cbiAgICAgICAgdmFyIGNoaWxkMSA9IHRoaXMuY29udGVudFtjaGlsZDFOXTtcbiAgICAgICAgdmFyIGNoaWxkMVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMSk7XG4gICAgICAgIC8vIElmIHRoZSBzY29yZSBpcyBsZXNzIHRoYW4gb3VyIGVsZW1lbnQncywgd2UgbmVlZCB0byBzd2FwLlxuICAgICAgICBpZiAoY2hpbGQxU2NvcmUgPCBlbGVtU2NvcmUpIHtcbiAgICAgICAgICBzd2FwID0gY2hpbGQxTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG8gdGhlIHNhbWUgY2hlY2tzIGZvciB0aGUgb3RoZXIgY2hpbGQuXG4gICAgICBpZiAoY2hpbGQyTiA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgY2hpbGQyID0gdGhpcy5jb250ZW50W2NoaWxkMk5dO1xuICAgICAgICB2YXIgY2hpbGQyU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQyKTtcbiAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT09IG51bGwgPyBlbGVtU2NvcmUgOiBjaGlsZDFTY29yZSkpIHtcbiAgICAgICAgICBzd2FwID0gY2hpbGQyTjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBuZWVkcyB0byBiZSBtb3ZlZCwgc3dhcCBpdCwgYW5kIGNvbnRpbnVlLlxuICAgICAgaWYgKHN3YXAgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50W25dID0gdGhpcy5jb250ZW50W3N3YXBdO1xuICAgICAgICB0aGlzLmNvbnRlbnRbc3dhcF0gPSBlbGVtZW50O1xuICAgICAgICBuID0gc3dhcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgYXJlIGRvbmUuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgZXVjbGlkZWFuIGFzIGV1Y2xpZGVhbkRpc3RhbmNlIH0gZnJvbSAnbWwtZGlzdGFuY2UtZXVjbGlkZWFuJztcblxuaW1wb3J0IEtEVHJlZSBmcm9tICcuL0tEVHJlZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtOTiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGxhYmVsc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaz1udW1iZXJPZkNsYXNzZXMgKyAxXSAtIE51bWJlciBvZiBuZWlnaGJvcnMgdG8gY2xhc3NpZnkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmRpc3RhbmNlPWV1Y2xpZGVhbkRpc3RhbmNlXSAtIERpc3RhbmNlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdHdvIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhc2V0LCBsYWJlbHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChkYXRhc2V0ID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBtb2RlbCA9IGxhYmVscztcbiAgICAgIHRoaXMua2RUcmVlID0gbmV3IEtEVHJlZShtb2RlbC5rZFRyZWUsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5rID0gbW9kZWwuaztcbiAgICAgIHRoaXMuY2xhc3NlcyA9IG5ldyBTZXQobW9kZWwuY2xhc3Nlcyk7XG4gICAgICB0aGlzLmlzRXVjbGlkZWFuID0gbW9kZWwuaXNFdWNsaWRlYW47XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NlcyA9IG5ldyBTZXQobGFiZWxzKTtcblxuICAgIGNvbnN0IHsgZGlzdGFuY2UgPSBldWNsaWRlYW5EaXN0YW5jZSwgayA9IGNsYXNzZXMuc2l6ZSArIDEgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkoZGF0YXNldC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwb2ludHNbaV0gPSBkYXRhc2V0W2ldLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgcG9pbnRzW2ldLnB1c2gobGFiZWxzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLmtkVHJlZSA9IG5ldyBLRFRyZWUocG9pbnRzLCBkaXN0YW5jZSk7XG4gICAgdGhpcy5rID0gaztcbiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzO1xuICAgIHRoaXMuaXNFdWNsaWRlYW4gPSBkaXN0YW5jZSA9PT0gZXVjbGlkZWFuRGlzdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEtOTiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBtb2RlbC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpc3RhbmNlPWV1Y2xpZGVhbkRpc3RhbmNlIC0gZGlzdGFuY2UgZnVuY3Rpb24gbXVzdCBiZSBwcm92aWRlZCBpZiB0aGUgbW9kZWwgd2Fzbid0IHRyYWluZWQgd2l0aCBldWNsaWRlYW4gZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge0tOTn1cbiAgICovXG4gIHN0YXRpYyBsb2FkKG1vZGVsLCBkaXN0YW5jZSA9IGV1Y2xpZGVhbkRpc3RhbmNlKSB7XG4gICAgaWYgKG1vZGVsLm5hbWUgIT09ICdLTk4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbW9kZWw6ICR7bW9kZWwubmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKCFtb2RlbC5pc0V1Y2xpZGVhbiAmJiBkaXN0YW5jZSA9PT0gZXVjbGlkZWFuRGlzdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2EgY3VzdG9tIGRpc3RhbmNlIGZ1bmN0aW9uIHdhcyB1c2VkIHRvIGNyZWF0ZSB0aGUgbW9kZWwuIFBsZWFzZSBwcm92aWRlIGl0IGFnYWluJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1vZGVsLmlzRXVjbGlkZWFuICYmIGRpc3RhbmNlICE9PSBldWNsaWRlYW5EaXN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndGhlIG1vZGVsIHdhcyBjcmVhdGVkIHdpdGggdGhlIGRlZmF1bHQgZGlzdGFuY2UgZnVuY3Rpb24uIERvIG5vdCBsb2FkIGl0IHdpdGggYW5vdGhlciBvbmUnXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEtOTih0cnVlLCBtb2RlbCwgZGlzdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIEpTT04gY29udGFpbmluZyB0aGUga2QtdHJlZSBtb2RlbC5cbiAgICogQHJldHVybiB7b2JqZWN0fSBKU09OIEtOTiBtb2RlbC5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ0tOTicsXG4gICAgICBrZFRyZWU6IHRoaXMua2RUcmVlLFxuICAgICAgazogdGhpcy5rLFxuICAgICAgY2xhc3NlczogQXJyYXkuZnJvbSh0aGlzLmNsYXNzZXMpLFxuICAgICAgaXNFdWNsaWRlYW46IHRoaXMuaXNFdWNsaWRlYW5cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFByZWRpY3RzIHRoZSBvdXRwdXQgZ2l2ZW4gdGhlIG1hdHJpeCB0byBwcmVkaWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhc2V0XG4gICAqIEByZXR1cm4ge0FycmF5fSBwcmVkaWN0aW9uc1xuICAgKi9cbiAgcHJlZGljdChkYXRhc2V0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YXNldCkpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldFswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpbmdsZVByZWRpY3Rpb24odGhpcywgZGF0YXNldCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KGRhdGFzZXRbMF0pICYmXG4gICAgICAgIHR5cGVvZiBkYXRhc2V0WzBdWzBdID09PSAnbnVtYmVyJ1xuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb25zID0gbmV3IEFycmF5KGRhdGFzZXQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcHJlZGljdGlvbnNbaV0gPSBnZXRTaW5nbGVQcmVkaWN0aW9uKHRoaXMsIGRhdGFzZXRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVkaWN0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YXNldCB0byBwcmVkaWN0IG11c3QgYmUgYW4gYXJyYXkgb3IgYSBtYXRyaXgnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTaW5nbGVQcmVkaWN0aW9uKGtubiwgY3VycmVudENhc2UpIHtcbiAgdmFyIG5lYXJlc3RQb2ludHMgPSBrbm4ua2RUcmVlLm5lYXJlc3QoY3VycmVudENhc2UsIGtubi5rKTtcbiAgdmFyIHBvaW50c1BlckNsYXNzID0ge307XG4gIHZhciBwcmVkaWN0ZWRDbGFzcyA9IC0xO1xuICB2YXIgbWF4UG9pbnRzID0gLTE7XG4gIHZhciBsYXN0RWxlbWVudCA9IG5lYXJlc3RQb2ludHNbMF1bMF0ubGVuZ3RoIC0gMTtcblxuICBmb3IgKHZhciBlbGVtZW50IG9mIGtubi5jbGFzc2VzKSB7XG4gICAgcG9pbnRzUGVyQ2xhc3NbZWxlbWVudF0gPSAwO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWFyZXN0UG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGN1cnJlbnRDbGFzcyA9IG5lYXJlc3RQb2ludHNbaV1bMF1bbGFzdEVsZW1lbnRdO1xuICAgIHZhciBjdXJyZW50UG9pbnRzID0gKytwb2ludHNQZXJDbGFzc1tjdXJyZW50Q2xhc3NdO1xuICAgIGlmIChjdXJyZW50UG9pbnRzID4gbWF4UG9pbnRzKSB7XG4gICAgICBwcmVkaWN0ZWRDbGFzcyA9IGN1cnJlbnRDbGFzcztcbiAgICAgIG1heFBvaW50cyA9IGN1cnJlbnRQb2ludHM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZWRpY3RlZENsYXNzO1xufVxuIiwiaW1wb3J0IEtOTiBmcm9tICdtbC1rbm4nXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoS05lYXJlc3ROZWlnaGJvcnMpIHtcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLnN0YXJ0UHJlZGljdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0KClcclxuICB9XHJcbiAgICBcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLnN0YXJ0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgLy90aGlzLmxvY2FsQ29uZmlnLm1vZGVsSlNPTiA9IG51bGxcclxuICAgIHRoaXMuY29uZmlnLmxvYWRpbmdQcm9ncmVzcyA9IDBcclxuICAgIC8vIGNvbnNvbGUubG9nKCdzdGFydCcsIDEpXHJcbiAgICBcclxuICAgIHRoaXMubG9jYWxDb25maWcubW9kZWxKU09OID0gbnVsbFxyXG4gICAgdGhpcy5sb2NhbENvbmZpZy5tb2RlbEV2YWx1YXRpb25zID0gW11cclxuICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy4kcGFyZW50LmdldFZlY3RvckRhdGEoKVxyXG4gICAgXHJcbiAgICB0aGlzLmRhdGFUb1Nob3cgPSBkYXRhXHJcbiAgICBcclxuICAgIGlmIChkYXRhLnRyYWluU2V0Q2xhc3Nlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTm8gdHJhaW5TZXRDbGFzc2VzJylcclxuICAgICAgLy90aHJvdyBFcnJvcignTm8gdHJhaW5TZXRDbGFzc2VzJylcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gY29uc29sZS5sb2coZGF0YSlcclxuICAgIC8vcmV0dXJuIGZhbHNlXHJcbiAgICB0aGlzLmNvbmZpZy5sb2FkaW5nUHJvZ3Jlc3MgPSAwLjI1XHJcbiAgICBcclxuICAgIC8vIGNvbnNvbGUubG9nKCdzdGFydCcsIDIpXHJcbiAgICAvL2NvbnNvbGUubG9nKGRhdGEudHJhaW5TZXRbMF0pXHJcbiAgICBcclxuICAgIC8vIGNvbnNvbGUubG9nKCdzdGFydCcsIDMpXHJcbiAgICBpZiAoZGF0YS50cmFpblNldENsYXNzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBpZiAoIXRoaXMubG9jYWxDb25maWcubW9kZWxKU09OKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuYnVpbGRNb2RlbChkYXRhKVxyXG4gICAgICAgIHRoaXMubG9jYWxDb25maWcubW9kZWxKU09OID0gdGhpcy5tb2RlbFxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBLTk4ubG9hZCh0aGlzLmxvY2FsQ29uZmlnLm1vZGVsSlNPTilcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm1vZGVsLnRvSlNPTigpKVxyXG5cclxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm1vZGVsKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZygnc3RhcnQnLCA1KVxyXG5cclxuICAgICAgdGhpcy5jb25maWcubG9hZGluZ1Byb2dyZXNzID0gMC41XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZygnc3RhcnQnLCA5KVxyXG4gICAgICAvL2NvbnNvbGUubG9nKGRhdGEudGVzdFNldClcclxuICAgICAgbGV0IHByZWRpY3RWZWN0b3IgPSBhd2FpdCB0aGlzLmdldFByZWRpY3RSZXN1bHRzVmVjdG9yKHRoaXMubW9kZWwsIGRhdGEpXHJcbiAgICAgIGxldCBwcmVkaWN0UmVzdWx0cyA9IGF3YWl0IHRoaXMuZ2V0UHJlZGljdFJlc3VsdHNWYWx1ZShkYXRhLCBwcmVkaWN0VmVjdG9yKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhwcmVkaWN0VmVjdG9yKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhwcmVkaWN0UmVzdWx0cylcclxuICAgICAgaWYgKHByZWRpY3RSZXN1bHRzWzBdID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnLmxvYWRpbmdQcm9ncmVzcyA9IDFcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdwcmVkaWN0IGlzIHVuZGVmaW5lZCcpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdzdGFydCcsIDEwKVxyXG4gICAgICB0aGlzLmNvbmZpZy5sb2FkaW5nUHJvZ3Jlc3MgPSAwLjc1XHJcblxyXG4gICAgICBpZiAodGhpcy4kcGFyZW50Lmhhc01vZGVsRXZhbHVhdGVkID09PSBmYWxzZSkge1xyXG4gICAgICAgIGxldCB0ZXN0U2V0Um93SW5kZXhlcyA9IGRhdGEudGVzdFNldFJvd0luZGV4ZXNcclxuICAgICAgICB0aGlzLnVua25vd25zUHJlZGljdGlvbiA9IFtdXHJcbiAgICAgICAgbGV0IHByZWRpY3RWZWN0b3JUb0V2YWx1dGUgPSBwcmVkaWN0VmVjdG9yLmZpbHRlcigodmFsdWUsIGkpID0+IHtcclxuICAgICAgICAgIGxldCBub3RNYXRjaCA9ICh0ZXN0U2V0Um93SW5kZXhlcy5pbmRleE9mKGkpID09PSAtMSlcclxuXHJcbiAgICAgICAgICBpZiAobm90TWF0Y2ggPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5rbm93bnNQcmVkaWN0aW9uLnB1c2godmFsdWUpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5vdE1hdGNoXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLmV2YWx1YXRpb25SZXN1bHRzKGRhdGEudHJhaW5TZXRDbGFzc2VzLCBwcmVkaWN0VmVjdG9yVG9FdmFsdXRlKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvL2NvbnNvbGUubG9nKHByZWRpY3RSZXN1bHRzKVxyXG4gICAgICB0aGlzLiRwYXJlbnQuc2V0UHJlZGljdFJlc3VsdHMocHJlZGljdFJlc3VsdHMpXHJcblxyXG4gICAgICB0aGlzLmNvbmZpZy5sb2FkaW5nUHJvZ3Jlc3MgPSAwLjlcclxuXHJcbiAgICB9IC8vIGlmIChkYXRhLnRyYWluU2V0Q2xhc3Nlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5tb2RlbCA9ICd1bnN1cGVydmlzZWQnXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0aGlzLiRwYXJlbnQuaXNNb2RlbFdpbmRvd09wZW5lZCkge1xyXG4gICAgICB0aGlzLnNob3dNb2RlbCgpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuY29uZmlnLmxvYWRpbmdQcm9ncmVzcyA9IDFcclxuICAgIHRoaXMuY29uZmlnLm1vZGVsQnVpbGRlZFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpXHJcbiAgfVxyXG4gIFxyXG4gIEtOZWFyZXN0TmVpZ2hib3JzLm1ldGhvZHMuYnVpbGRNb2RlbCA9IGZ1bmN0aW9uIChkYXRhKXtcclxuICAgIGxldCB7dGVzdFNldFJvd0luZGV4ZXMsIHRyYWluU2V0Um93SW5kZXhlc30gPSBkYXRhXHJcbiAgICAvLyBjb25zb2xlLmxvZyh0ZXN0U2V0Um93SW5kZXhlcywgdHJhaW5TZXRSb3dJbmRleGVzKVxyXG4gICAgbGV0IGRhdGFzZXQgPSBkYXRhLnRlc3RTZXQuZmlsdGVyKChyb3csIGkpID0+IHtcclxuICAgICAgcmV0dXJuICh0ZXN0U2V0Um93SW5kZXhlcy5pbmRleE9mKGkpID09PSAtMSlcclxuICAgIH0pXHJcbiAgICAvLyBsZXQgZGF0YXNldCA9IGRhdGEudHJhaW5TZXRcclxuICAgIFxyXG4gICAgLy8gY29uc29sZS5sb2coZGF0YXNldClcclxuICAgIGxldCBwcmVkaWN0aW9ucyA9IGRhdGEudHJhaW5TZXRDbGFzc2VzXHJcbiAgICAvLyBjb25zb2xlLmxvZyhwcmVkaWN0aW9ucylcclxuICAgIFxyXG4gICAgaWYgKGRhdGFzZXQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGRhdGFzZXQgPSBkYXRhLnRlc3RTZXRcclxuICAgICAgcHJlZGljdGlvbnMgPSBkYXRhc2V0Lm1hcChpdGVtID0+ICd1bmtub3duJylcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKGRhdGFzZXQubGVuZ3RoICE9PSBwcmVkaWN0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignbGVuZ3RoIGlzIG5vdCBtYXRjaCcpXHJcbiAgICB9XHJcbiAgICAvLyBjb25zb2xlLmxvZygnb2snKVxyXG4gICAgcmV0dXJuIG5ldyBLTk4oZGF0YXNldCwgcHJlZGljdGlvbnMsIHtcclxuICAgICAgazogdGhpcy5sb2NhbENvbmZpZy5LTmVhcmVzdE5laWdoYm9yc09wdGlvbnNLXHJcbiAgICB9KVxyXG4gIH1cclxuICBcclxuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLmdldFByZWRpY3RSZXN1bHRzVmVjdG9yID0gYXN5bmMgZnVuY3Rpb24gKG1vZGVsLCBkYXRhKSB7XHJcbiAgICBsZXQgdGVzdFNldCA9IGRhdGEudGVzdFNldFxyXG4gICAgbGV0IHJlc3VsdFZlY3RvciA9IG1vZGVsLnByZWRpY3QodGVzdFNldCk7XHJcbiAgICByZXR1cm4gcmVzdWx0VmVjdG9yXHJcbiAgfVxyXG4gIFxyXG4gIEtOZWFyZXN0TmVpZ2hib3JzLm1ldGhvZHMuZ2V0UHJlZGljdFJlc3VsdHNWYWx1ZSA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhLCByZXN1bHRWZWN0b3IpIHtcclxuICAgIGxldCB0cmFpblNldENsYXNzZXNEaWN0ID0gZGF0YS50cmFpblNldENsYXNzZXNEaWN0XHJcbiAgICAvL2NvbnNvbGUubG9nKHRyYWluU2V0Q2xhc3Nlc0RpY3QpXHJcbiAgICByZXR1cm4gcmVzdWx0VmVjdG9yLm1hcChpbmRleCA9PiB7XHJcbiAgICAgIHJldHVybiB0cmFpblNldENsYXNzZXNEaWN0W2luZGV4XVxyXG4gICAgfSlcclxuICB9XHJcbiAgXHJcbiAgS05lYXJlc3ROZWlnaGJvcnMubWV0aG9kcy5ldmFsdWF0aW9uUmVzdWx0cyA9IGFzeW5jIGZ1bmN0aW9uICh0cmFpbiwgcHJlZGljdCkge1xyXG4gICAgXHJcbiAgICB0aGlzLiRwYXJlbnQucmVzZXRNb2RlbEV2YWx1YXRpb24oKVxyXG4gICAgLy8gY29uc29sZS5sb2codHJhaW4pXHJcbiAgICAvLyBjb25zb2xlLmxvZyhwcmVkaWN0KVxyXG4gICAgLy9jb25zb2xlLmxvZyhkYXRhLnRyYWluU2V0Q2xhc3Nlcy5sZW5ndGgsIGdldFRyYWluU2V0UHJlZGljdHMubGVuZ3RoLCBkYXRhLnRlc3RTZXRSb3dJbmRleGVzLmxlbmd0aClcclxuXHJcbiAgICBsZXQgYWNjdXJhY3kgPSBhd2FpdCB0aGlzLiRwYXJlbnQuY2FsY0FjY3VyYWN5KHRyYWluLCBwcmVkaWN0KVxyXG4gICAgLy9jb25zb2xlLmxvZyhhY2N1cmFjeSlcclxuICAgIGxldCBhY2N1cmFjeUluZm8gPSB7XHJcbiAgICAgIG5hbWU6ICdhY2N1cmFjeScsXHJcbiAgICAgIHR5cGU6ICdwZXJjZW50JyxcclxuICAgICAgdmFsdWU6IGFjY3VyYWN5XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vY29uc29sZS5sb2coYWNjdXJhY3lJbmZvKVxyXG4gICAgdGhpcy5sb2NhbENvbmZpZy5tb2RlbEV2YWx1YXRpb25zLnB1c2goYWNjdXJhY3lJbmZvKVxyXG4gIH1cclxufSIsIi8vaW1wb3J0IHtldWNsaWRlYW59IGZyb20gJ21sLWRpc3RhbmNlLWV1Y2xpZGVhbidcbmNvbnN0IGV1Y2xpZGVhbiA9IHJlcXVpcmUoJ21sLWRpc3RhbmNlLWV1Y2xpZGVhbicpLmV1Y2xpZGVhblxuLy9jb25zdCBldWNsaWRlYW4gPSBNTERpc3RhbmNlRXVjbGlkZWFuLmV1Y2xpZGVhblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoS05lYXJlc3ROZWlnaGJvcnMpIHtcbiAgS05lYXJlc3ROZWlnaGJvcnMubWV0aG9kcy5zaG93TW9kZWwgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5tb2RlbClcbiAgICBpZiAoIXRoaXMubW9kZWwpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnQoKVxuICAgICAgLy9jb25zb2xlLmVycm9yKCdubyB0aGlzLm1vZGVsJylcbiAgICAgIC8vcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL2NvbnNvbGUubG9nKHRoaXMuZGF0YVRvU2hvdylcbiAgICBsZXQgdW5rbm93blNldFJvd0luZGV4ID0gdGhpcy5kYXRhVG9TaG93LnRlc3RTZXRSb3dJbmRleGVzXG5cbiAgICBsZXQgbmVpZ2hib3JzID0gW11cbiAgICBsZXQgbmVpZ2hib3JzSUQgPSBbXVxuICAgIGxldCB1bmtub3ducyA9IFtdXG4gICAgbGV0IHVua25vd25zSUQgPSBbXVxuICAgIC8vY29uc29sZS5sb2codW5rbm93blNldFJvd0luZGV4KVxuXG4gICAgdGhpcy5kYXRhVG9TaG93LnRlc3RTZXQuZm9yRWFjaCgoc2V0LCBpKSA9PiB7XG4gICAgICBpZiAodW5rbm93blNldFJvd0luZGV4LmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgIG5laWdoYm9ycy5wdXNoKHNldClcbiAgICAgICAgbmVpZ2hib3JzSUQucHVzaChpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5rbm93bnMucHVzaChzZXQpXG4gICAgICAgIHVua25vd25zSUQucHVzaChpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAodW5rbm93bnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB1bmtub3ducyA9IFtdLmNvbmNhdChuZWlnaGJvcnMpXG4gICAgICB1bmtub3duc0lEID0gW10uY29uY2F0KG5laWdoYm9yc0lEKVxuICAgICAgdW5rbm93blNldFJvd0luZGV4ID0gW10uY29uY2F0KG5laWdoYm9yc0lEKVxuICAgIH1cblxuICAgIC8vY29uc29sZS5sb2cobmVpZ2hib3JzKVxuICAgIC8vIGNvbnNvbGUubG9nKHVua25vd25zKVxuICAgIGlmIChuZWlnaGJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZWlnaGJvcnMgPSB1bmtub3duc1xuICAgICAgbmVpZ2hib3JzSUQgPSB1bmtub3duc0lEXG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBsZXQgZGlzdGFuY2VNYXRyaXggPSB1bmtub3ducy5tYXAodW5rbm93bkZlYXR1cmUgPT4ge1xuICAgICAgbGV0IG1heERpc3RhbmNlID0gbnVsbFxuICAgICAgbGV0IGRpc3RhbmNlcyA9IG5laWdoYm9ycy5tYXAobmVpZ2hib3IgPT4ge1xuICAgICAgICBsZXQgZGlzdGFuY2UgPSBldWNsaWRlYW4odW5rbm93bkZlYXR1cmUsIG5laWdoYm9yKVxuICAgICAgICBpZiAobWF4RGlzdGFuY2UgPT09IG51bGwgfHwgZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgIG1heERpc3RhbmNlID0gZGlzdGFuY2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0YW5jZVxuICAgICAgfSlcblxuICAgICAgZGlzdGFuY2VzID0gZGlzdGFuY2VzLm1hcChkID0+IHtcbiAgICAgICAgcmV0dXJuICgobWF4RGlzdGFuY2UgLSBkKSAvIG1heERpc3RhbmNlKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGRpc3RhbmNlc1xuICAgIH0pXG5cbiAgICAvLyBjb25zb2xlLmxvZyhkaXN0YW5jZU1hdHJpeClcblxuICAgIC8vIGNvbnNvbGUubG9nKGRpc3RhbmNlTWF0cml4KVxuICAgIGlmIChkaXN0YW5jZU1hdHJpeC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IEVycm9yKCdEaXN0YW5jZSBtYXRyaXggaXMgZW1wdHknKVxuICAgIH1cblxuICAgIGxldCBjb2xvck1hdHJpeCA9IGRpc3RhbmNlTWF0cml4Lm1hcCh1bmtub3duID0+IHtcbiAgICAgIHJldHVybiB1bmtub3duLm1hcChkID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYXRNYXBDb2xvcmZvclZhbHVlKGQpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICAvL2NvbnNvbGUubG9nKGNvbG9yTWF0cml4KVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCB0YWJsZUhlYWRlclVua25vd25Db2xzcGFuID0gMlxuICAgIGlmICh0aGlzLm1vZGVsID09PSAndW5zdXBlcnZpc2VkJykge1xuICAgICAgdGFibGVIZWFkZXJVbmtub3duQ29sc3BhbiA9IDFcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyh7dGFibGVIZWFkZXJVbmtub3duQ29sc3BhbiwgY29sb3JNYXRyaXh9KVxuXG4gICAgbGV0IHRhYmxlSGVhZGVyID0gYDx0aGVhZD5cbiAgPHRyPlxuICAgIDx0aCByb3dzcGFuPVwiMlwiIGNvbHNwYW49XCIke3RhYmxlSGVhZGVyVW5rbm93bkNvbHNwYW59XCIgdmFsaWduPVwiYm90dG9tXCI+JHt0aGlzLiR0KCdVbmtub3ducycpfTwvdGg+XG4gICAgPHRoIGNvbHNwYW49XCIke2NvbG9yTWF0cml4WzBdLmxlbmd0aH1cIj4ke3RoaXMuJHQoJ05laWdoYm9ycycpfTwvdGg+XG4gIDwvdHI+XG4gIDx0cj4ke2NvbG9yTWF0cml4WzBdLm1hcCgodmFsdWUsIGkpID0+IGA8dGg+JHtuZWlnaGJvcnNJRFtpXSArIDF9PC90aD5gKS5qb2luKCcnKX08L3RyPlxuPC90aGVhZD5gXG5cbiAgICBsZXQgdHJhaW5TZXRDbGFzc2VzRGljdCA9IHRoaXMuZGF0YVRvU2hvdy50cmFpblNldENsYXNzZXNEaWN0XG4gICAgbGV0IHVua25vd25zUHJlZGljdGlvbiA9IHRoaXMudW5rbm93bnNQcmVkaWN0aW9uXG4gICAgLy8gY29uc29sZS5sb2coe3RyYWluU2V0Q2xhc3Nlc0RpY3QsIHVua25vd25zUHJlZGljdGlvbn0pXG4gICAgaWYgKHVua25vd25zUHJlZGljdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGxldCBkYXRhID0gYXdhaXQgdGhpcy4kcGFyZW50LmdldFZlY3RvckRhdGEoKVxuICAgICAgLy8gbGV0IHByZWRpY3RWZWN0b3IgPSBhd2FpdCB0aGlzLmdldFByZWRpY3RSZXN1bHRzVmVjdG9yKHRoaXMubW9kZWwsIGRhdGEpXG4gICAgICAvLyBsZXQgcHJlZGljdFJlc3VsdHMgPSBhd2FpdCB0aGlzLmdldFByZWRpY3RSZXN1bHRzVmFsdWUoZGF0YSwgcHJlZGljdFZlY3RvcilcbiAgICAgIC8vIGNvbnNvbGUubG9nKHByZWRpY3RWZWN0b3IpXG4gICAgICAvLyBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgdW5rbm93bnNQcmVkaWN0aW9uID0gYXdhaXQgdGhpcy4kcGFyZW50LmdldFRyYWluU2V0UHJlZGljdHNSZXN1bHQoKVxuICAgICAgLy8gdGhyb3cgRXJyb3IoJ3RvZG8nKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHVua25vd25zUHJlZGljdGlvbiA9IHVua25vd25zUHJlZGljdGlvbi5tYXAoaSA9PiB0cmFpblNldENsYXNzZXNEaWN0W2ldKVxuICAgIH1cblxuICAgIGxldCB0YWJsZUJvZHkgPSBgPHRib2R5PlxuJHtjb2xvck1hdHJpeC5tYXAoKHJvdywgaSkgPT4ge1xuICAgICAgbGV0IHRoUHJlZGllY3Rpb24gPSBgPHRoPiR7dW5rbm93bnNQcmVkaWN0aW9uW2ldfTwvdGg+YFxuICAgICAgaWYgKHRoaXMubW9kZWwgPT09ICd1bnN1cGVydmlzZWQnKSB7XG4gICAgICAgIHRoUHJlZGllY3Rpb24gPSAnJ1xuICAgICAgfVxuICAgICAgcmV0dXJuIGA8dHI+XG4gIDx0aD4keyh1bmtub3duU2V0Um93SW5kZXhbaV0pICsgMX08L3RoPlxuICAke3RoUHJlZGllY3Rpb259XG4gICR7cm93Lm1hcCgoY29sb3IsIGopID0+IHtcbiAgICAgICAgbGV0IGQgPSBkaXN0YW5jZU1hdHJpeFtpXVtqXVxuICAgICAgICBsZXQgZFRleHQgPSBkXG4gICAgICAgIGRUZXh0ID0gTWF0aC5yb3VuZChkVGV4dCAqIDEwMCkgKyAnJSdcblxuICAgICAgICBpZiAoZCA+IDAuNyB8fCBkIDwgMC4zKSB7XG4gICAgICAgICAgcmV0dXJuIGA8dGQgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yfTsgY29sb3I6IHdoaXRlXCI+JHtkVGV4dH08L3RkPmBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYDx0ZCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9XCI+JHtkVGV4dH08L3RkPmBcbiAgICAgICAgfVxuICAgICAgfSkuam9pbignJyl9XG48L3RyPmBcbiAgICB9KS5qb2luKCdcXG4nKX1cbjwvdGJvZHk+YFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGNvbnNvbGUubG9nKHRhYmxlQm9keSlcblxuICAgIGxldCBib2R5SFRNTCA9IGA8dGFibGUgYm9yZGVyPVwiMVwiIGFsaWduPVwiY2VudGVyXCI+XG4gICAgJHt0YWJsZUhlYWRlcn1cbiAgICAke3RhYmxlQm9keX1cbjwvdGFibGU+YFxuICAgIGJvZHlIVE1MID0gYDxkaXYgY2xhc3M9XCJ0cmVlXCI+JHtib2R5SFRNTH08L2Rpdj5gXG4gICAgLy9jb25zb2xlLmVycm9yKCdbVE9ET10nKVxuICAgIC8vY29uc29sZS5sb2coKVxuICAgIGxldCB0aXRsZSA9IHRoaXMuJHQoJ0tOTicpICsgYCAoYCArIChuZXcgRGF0ZSgpKS5tbWRkaGhtbSgpICsgJyknXG5cbiAgICAvLyBjb25zb2xlLmxvZygnS05OTW9kZWxTaG93JyArIHRoaXMuY29uZmlnLm1vZGVsQnVpbGRlZFRpbWUpXG4gICAgbGV0IG1vZGVsV2luZG93ID0gdGhpcy51dGlscy5Qb3B1cFV0aWxzLm9wZW4oe1xuICAgICAgd2luZG93TmFtZTogJ0tOTk1vZGVsU2hvdycgKyB0aGlzLmNvbmZpZy5tb2RlbEJ1aWxkZWRUaW1lLFxuICAgICAgY3NzVVJMOiB0aGlzLm1vZGVsQ1NTVVJMLFxuICAgICAgYm9keUhUTUwsXG4gICAgICBzaXplOiAncmlnaHQnLFxuICAgICAgLy9zaXplOiAnbGVmdCcsXG4gICAgICB0aXRsZVxuICAgIH0pXG5cbiAgICBtb2RlbFdpbmRvdy5zY3JvbGxUb1RvcCgpXG4gICAgbW9kZWxXaW5kb3cuc2Nyb2xsVG9DZW50ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNzI2MzkxOC82NjQ1Mzk5XG4gICAqL1xuICBmdW5jdGlvbiBoZWF0TWFwQ29sb3Jmb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBoID0gKDEuMCAtIHZhbHVlKSAqIDI0MFxuICAgIHJldHVybiBcImhzbChcIiArIGggKyBcIiwgMTAwJSwgNTAlKVwiO1xuICAgIC8vcmV0dXJuIGByZ2JhKDIyLCAxNjAsIDEzMywgJHt2YWx1ZX0pYFxuICAgIC8vIHJnYigyMiwgMTYwLCAxMzMpXG4gIH1cbn1cbiIsImltcG9ydCBLTk4gZnJvbSAnbWwta25uJ1xuLy8gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWwta25uXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChLTmVhcmVzdE5laWdoYm9ycykge1xuICBLTmVhcmVzdE5laWdoYm9ycy5tZXRob2RzLnRlc3RLTk4gPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFzZXQgPSBbXG4gICAgICBbMCwgMCwgMF0sXG4gICAgICBbMCwgMSwgMV0sXG4gICAgICBbMSwgMSwgMF0sXG4gICAgICBbMiwgMiwgMl0sXG4gICAgICBbMSwgMiwgMl0sXG4gICAgICBbMiwgMSwgMl1cbiAgICBdO1xuICAgIHZhciBwcmVkaWN0aW9ucyA9IFswLCAwLCAwLCAxLCAxLCAxXTtcbiAgICB2YXIga25uID0gbmV3IEtOTihkYXRhc2V0LCBwcmVkaWN0aW9ucyk7XG4gICAgXG4gICAgdmFyIGRhdGFzZXQgPSBbWzAsIDAsIDBdLCBbMiwgMiwgMl1dO1xuIFxuICAgIHZhciBhbnMgPSBrbm4ucHJlZGljdChkYXRhc2V0KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhhbnMpXG4gIH1cbn0iLCJsZXQgS05lYXJlc3ROZWlnaGJvcnMgPSB7XG4gIHByb3BzOiBbJ2NvbmZpZycsICdsb2NhbENvbmZpZycsICd1dGlscyddLFxuICBkYXRhICgpIHsgICAgXG4gICAgdGhpcy4kaTE4bi5sb2NhbGUgPSB0aGlzLmxvY2FsQ29uZmlnLmxvY2FsZVxuICAgIHJldHVybiB7XG4gICAgICBtb2RlbDogbnVsbCxcbiAgICAgIGRhdGFUb1Nob3c6IG51bGwsXG4gICAgICB1bmtub3duc1ByZWRpY3Rpb246IFtdLFxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAnbG9jYWxDb25maWcubG9jYWxlJygpIHtcbiAgICAgIHRoaXMuJGkxOG4ubG9jYWxlID0gdGhpcy5sb2NhbENvbmZpZy5sb2NhbGU7XG4gICAgfSxcbiAgICAnbG9jYWxDb25maWcuS05lYXJlc3ROZWlnaGJvcnNPcHRpb25zSycgKCkge1xuICAgICAgdGhpcy4kcGFyZW50LmNsZWFyUHJlZGljdGlvbigpXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzTW9kZWxCdWlsZGVkICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tb2RlbCAhPT0gbnVsbClcbiAgICB9LFxuICAgIGlzTW9kZWxVbnN1cGVydmlzZWQgKCkge1xuICAgICAgcmV0dXJuICh0aGlzLm1vZGVsICE9PSBudWxsICYmIHRoaXMubW9kZWwgPT09ICd1bnN1cGVydmlzZWQnKVxuICAgIH0sXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4vLyAgICBzZXRUaW1lb3V0KCgpID0+IHtcbi8vICAgICAgdGhpcy5zdGFydCgpXG4vLyAgICB9LCAxMDAwKVxuXG4gICAgLy90aGlzLnRlc3RLTk4oKVxuICB9LFxuICBtZXRob2RzOiB7fVxufVxuXG5pbXBvcnQgS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzQnVpbGQgZnJvbSAnLi9LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNCdWlsZC5qcydcbktOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc0J1aWxkKEtOZWFyZXN0TmVpZ2hib3JzKVxuXG5pbXBvcnQgS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzU2hvdyBmcm9tICcuL0tOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Nob3cuanMnXG5LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNTaG93KEtOZWFyZXN0TmVpZ2hib3JzKVxuXG5pbXBvcnQgS05lYXJlc3ROZWlnaGJvcnNNZXRob2RzVGVzdCBmcm9tICcuL0tOZWFyZXN0TmVpZ2hib3JzTWV0aG9kc1Rlc3QuanMnXG5LTmVhcmVzdE5laWdoYm9yc01ldGhvZHNUZXN0KEtOZWFyZXN0TmVpZ2hib3JzKVxuXG5leHBvcnQgZGVmYXVsdCBLTmVhcmVzdE5laWdoYm9ycyIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNiEuL0tOZWFyZXN0TmVpZ2hib3JzLmpzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTYhLi9LTmVhcmVzdE5laWdoYm9ycy5qcz92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vS05lYXJlc3ROZWlnaGJvcnMuaHRtbD92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xMjk1MjQ1YyZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9LTmVhcmVzdE5laWdoYm9ycy5qcz92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vS05lYXJlc3ROZWlnaGJvcnMuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vS05lYXJlc3ROZWlnaGJvcnMubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTEyOTUyNDVjJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMTI5NTI0NWNcIixcbiAgbnVsbFxuICBcbilcblxuLyogY3VzdG9tIGJsb2NrcyAqL1xuaW1wb3J0IGJsb2NrMCBmcm9tIFwiLi9LTmVhcmVzdE5laWdoYm9ycy55YW1sP3Z1ZSZ0eXBlPWN1c3RvbSZpbmRleD0wJmJsb2NrVHlwZT1pMThuJmlzc3VlclBhdGg9JTJGYXBwJTJGc3JjJTJGY29tcG9uZW50cyUyRkNvbmZpZ3VyYXRpb25QYW5lbCUyRktOZWFyZXN0TmVpZ2hib3JzJTJGS05lYXJlc3ROZWlnaGJvcnMudnVlJmxhbmc9eWFtbFwiXG5pZiAodHlwZW9mIGJsb2NrMCA9PT0gJ2Z1bmN0aW9uJykgYmxvY2swKGNvbXBvbmVudClcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvYXBwL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzEyOTUyNDVjJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzEyOTUyNDVjJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzEyOTUyNDVjJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9LTmVhcmVzdE5laWdoYm9ycy5odG1sP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTEyOTUyNDVjJnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzEyOTUyNDVjJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9Db25maWd1cmF0aW9uUGFuZWwvS05lYXJlc3ROZWlnaGJvcnMvS05lYXJlc3ROZWlnaGJvcnMudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUhBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7QUN4SkE7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1S0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQzdDQTs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFpQkE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///576\n')}}]);